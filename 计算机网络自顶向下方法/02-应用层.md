### 2.1 应用层协议原理

- 网络核心设备并不在应用层上起作用，而仅在较低层起作用，特别是在网络层及下面层次起作用，这种基本设计将应用软件限制在端系统对额方法，促进了大量网络应用程序的迅速开发和部署

#### 2.1.1 网络应用程序体系结构

- 从应用程序研发者角度看，网络体系结构是固定的，并为应用程序提供了特定的服务集合。应用程序体系结构由应用程序研发者规定了如何在各种端系统上组织该应用程序

- 网络应用程序的两种主流体系结构：

  1. 客户-服务器体系结构：总是有一个打开的主机称为服务器，其服务于来自许多其他称为客户的主机的请求，客户相互之间不直接通信。服务器具有固定的、周知的地址。

     在一个客户-服务器应用中，常常会出现一台单独的服务器主机跟不上它所有客户请求的情况，为此配备大量主机的数据中心常被用于创建强大的虚拟服务器。一个数据中心能够有数十万台服务器，它们必须要供电和维护，且服务提供商必须支付不断出现的互联和带宽费用以发送和接受到达和来自数据中心的数据

  2. 对等体系结构：应用程序在间断连接的主机对之间使用直接通信，这些主机对称为对等方，它们并不为服务提供商所有，却为用户控制的桌面机和膝上机所有。其最大的特性之一是自扩展性。其也是有成本效率的，它们通常不需要庞大的服务器基础设施和服务器带宽。未来P2P应用由于高度非集中式，面临安全性、性能和可靠性等挑战

#### 2.1.2 进程通信

- 进行通信的是进程而不是程序，一个进程可以被认为是运行在端系统中的一个程序、当多个进程运行在相同的端系统上时，他们使用进程间通信机制相互通信，进程间通信的规则由端系统上的操作系统确定。两个不同端系统上的进程通过跨越计算机网络交换报文相互通信
- 网络应用程序由成对的进程组成，这些进程通过网络相互发送报文。在一对进程之间的通信会话场景中，发起通信的进程被标识为客户，在会话开始时等待联系的进程是服务器
- 进程通过一个称为套接字的软件接口向网络发送报文和从网络接收报文。套接字是同一台主机内应用层与运输层之间的接口，由于该套接字是建立网络应用程序的可编程接口，因此套接字也称为应用程序和网络之间的应用程序编程接口
- 应用程序开发者可以控制套接字在应用层端的一切，但对于套接字的运输层几乎没有控制权，仅限于选择运输层协议、设定一些运输层参数
- 为标识接收进程，需要定义两个信息：
  1. 主机的地址，因特网中由IP进行标识
  2. 目的主机中接收进程的标识，即端口号

#### 2.1.3 可供应用程序使用的运输服务

- 应用程序的服务要求大体可分为四类：
  1. 可靠数据传输：一个协议提供确保由应用程序的一端发送的数据正确的、完全的交付给该应用程序的另一端。当一个运输层协议不提供可靠数据传输时，由发送进程发送的某些数据可能到达不了接收进程，这可能能被容忍丢失的应用所接收
  2. 吞吐量：运输层协议能以某种特定的速率提供确保的可用吞吐量。具有吞吐量要求的应用被称为带宽敏感应用，许多多媒体应用在该类中。弹性应用能够根据当前可用的带宽或多或少的利用可供使用的吞吐量，如电子邮件、文件传输等
  3. 定时：其有多种形式的实现，如保证到达接收方的时间不超过一定量。这对于交互式实时应用程序有吸引力力，对于非实时应用，较低的时延总比高的好，但对端到端的时延没有严格约束
  4. 安全性：运输协议能够为应用程序提供一种或多种安全性服务。如加密发送进程传输的数据并在接受进程解密、数据完整性等

#### 2.1.4 因特网提供的运输服务

- 因特网更一般的是TCP/IP网络，为应用程序提供了两个运输层协议UDP和TCP，每个协议为调用它们的应用程序提供了不同的服务集合

- TCP服务模型包括两个服务：

  1. 面向连接服务：在应用层数据报文开始流动之前，TCP让客户和服务器互相交换运输层控制信息，该握手过程提醒客户和服务器，让它们为大量分组的到来做好准备。握手阶段后会在两个进程间建立一条全双工的TCP连接，双方进程可以在此连接上同时进行报文收发，当应用程序结束报文发送时必须拆除该连接
  2. 可靠数据传输服务：依靠TCP，无差错、按适当顺序交付所有发送的数据

- TCP还具有拥塞控制机制，该服务不一定能为通信进程带来直接的好处，但能为因特网带来整体好处

- 无论是TCP还是UDP都没有提供任何加密机制，发送进程传进其套接字的数据与经网络专属到目的进程的数据相同。

- 因特网界已经研制了TCP的加强版本，称为安全套接字层（Secure Sockets Layer，SSL），用SSL加强后的TCP不仅能够做传统的TCP所能做的一切，且提供了关键的进程到进程的安全性服务，包括加密、数据完整性、端点鉴别。其对TCP的强化是在应用层上实现的，若一个应用程序要使用SSL服务，需要在该应用程序的客户端和服务器端包括SSL代码。

- SSL有自己的套接字API，当第一个应用使用SSL时，发送进程向SSL套接字传递明文数据，在发送主机中的SSL则加密该数据并将加密的数据传递给TCP套接字。加密的数据经过因特网传送到接收进程中的TCP套接字，该接收套接字将加密数据传递给SSL，由其进行解密，最后SSL通过它的SSL套接字将明文数据传递给接收进程

- UDP是一种不提供不必要服务的轻量级运输协议，仅提供最小服务。它是无连接的看因此在两个进程通信前没有握手过程，其提供一种不可靠数据传输服务，当进程将一个报文发送进UDP套接字时，并不保证该报文将到达接收进程，且UDP没有包括拥塞控制机制，所以UDP发送端可以用它选定的任何速率向下层注入数据，但实际端到端的吞吐量可能小于该速率，可能是因为中间链路的带宽受限或因为拥塞而造成的

- 目前的因特网运输协议并没有提供对吞吐量和定时保证，所以应用程序被设计成尽最大可能对付这种保证的缺乏

- 流行的因特网应用及其应用层协议和支撑的运输协议

  | 应用         | 应用层协议              | 支撑的运输协议 |
  | ------------ | ----------------------- | -------------- |
  | 电子邮件     | SMTP                    | TCP            |
  | 远程终端访问 | Telnet                  | TCP            |
  | Web          | HTTP                    | TCP            |
  | 文件传输     | FTP                     | TCP            |
  | 流式多媒体   | HTTP                    | TCP            |
  | 因特网电话   | SIP、RTP或专用的如Skype | UDP或TCP       |

#### 2.1.5 应用层协议

- 应用层协议定义了运行在不同端系统上的应用程序进程如何相互传递报文，其定义了：

  - 交换的报文类型
  - 各种报文类型的语法
  - 字段的语义，即这些字段中的信息的含义
  - 确定一个进程何时以及如何发送报文，对报文进行响应的规则

  有些应用层协议是由RFC文档定义的，位于公共域中，还有很多别的应用层协议是专用的，不为公共域使用

- 应用层协议只是网络应用的一部分

### 2.2 Web和HTTP

#### 2.2.1 HTTP概况

- Web的应用层协议是超文本传输协议（HyperText Transfer Protocol，HTTP），在RFC 1945和RFC 2616中进行了定义
- HTTP由客户程序和服务器程序实现，它们运行在不同的端系统中，通过交换HTTP报文进行会话，HTTP定义了这些报文结构以及客户和服务器进行报文交换的方式
- Web页面是由对象组成的，一个对象只是一个文件，且它们可以通过一个URL地址寻址。多数Web页面含有一个HTML基本文件和几个引用对象，每个URL地址由两部分组成：存放对象的服务器主机名和对象的路径名
- Web浏览器实现了HTTP的客户端，Web服务器实现了HTTP的服务端，用于存储Web对象，每个对象由URL寻址
- HTTP定义了Web客户端向Web服务器请求Web页面的方式以及服务器向客户传送Web页面的方式
- HTTP是一个而无状态协议，服务器向客户发送被请求的文件，而不存储任何关于该客户的状态信息

#### 2.2.2 非持续连接和持续连接

- 在许多因特网应用程序中，客户和服务器在一个相当长的时间范围内通信，其中客户发出一系列请求且服务器对每个请求进行响应。当客户服务器之间是用TCP进行传输的，需要决定使用以下哪种方式：

  1. 非持续连接：每个请求/响应对是经过一个单独的TCP连接发送的
  2. 持续连接：所有的请求及相应经相同的TCP连接发送

  HTTP既能使用非持续连接，也能够使用持续连接，默认为持续

- HTTP在非持续连接中，每个TCP连接在服务器发送一个对象后关闭，即该连接并不为其他的对象而持续下来，每个TCP连接只传输一个请求报文和一个响应报文

- 往返时间（Round-Trip Time，RTT）：一个短分组从客户端到服务器然后再返回客户所花费的时间，包括分组传播时延、分组在中间路由器和交换机上的排队时延、分组处理时延

- 非持续连接的缺点：

  1. 必须为每一个请求的对象建立和维护一个去哪性的连接，对每个这样的连接在客户和服务器中都要分配TCP的缓冲区和保持TCP变量，给Web服务器带来了严重的负担
  2. 每一个对象经受两倍RTT的交付时延，一个RTT用于创建TCP，另一个RTT用于请求和接受一个对象

- 在采用HTTP1.1持续连接情况下，服务器在发送响应后保持该TCP连接打开，在相同的客户与服务器之间，后续的请求和响应报文能够通过相同的连接进行传送，特别是一个完整的Web页面可以用单个持续TCP连接进行传送，甚至位于同一台服务器的多个Web页面在从该服务器发送给同一个客户时，可以在单个连续TCP上进行，对对象的请求可以一个接一个的发出而不必等待回答。一般来说若一条连接经过一定时间间隔仍未被使用，HTTP服务器就关闭连接

#### 2.2.3 HTTP报文格式

- HTTP报文有两种：请求报文和响应报文

- HTTP请求报文：

  - 请求行，包含方法字段、URL字段、HTTP版本字段。方法字段包括GET、POST、HEAD、PUT、DELETE。
    - 绝大部分的HTTP请求报文使用GET方法，此时URL字段带有请求对象的标识
    - 当用户提交表单的时候HTTP客户端通常使用POST请求
    - HEAD类似于GET方法，当服务器收到一个使用HEAD方法的请求时，将会用一个HTTP报文进行响应，但是并不返回请求对象，开发整常用该方法进行调试跟踪
    - PUT也被那些需要向Web服务器上传对象的应用程序使用
    - DELETE方法允许用户或应用程序删除Web服务器上的对象

  - 首部行：
    - Host：指明了对象所在主机，该首部行提供的信息是Web代理告诉缓存所要求的
    - Connection：高速服务器是否使用可持续连接，为close则使用非持续连接
    - User-agent：指明用户代理，即向服务器发送的浏览器的类型，通过该首部行服务器可以有效的为不同类型的用户代理发送相同的对象的不同版本
    - Accept-language：用户想要得到该对象的语言版本，若不存在该版本则发送默认版本
  - 实体体：使用GET方法时为空，使用POST方法时才使用该实体体。

- HTTP响应报文：

  - 状态行：包含协议版本字段、状态码、相应状态信息

    常见状态码：

    - 200 OK：请求成功，信息在返回的响应报文中
    - 301 Moved Permanently：请求的对象已经被永久转移了，新的URL定义在响应报文的Location首部行中，客户软件将自动获取新的URL
    - 400 Bad Request：通用差错代码，该请求不能被服务器解析
    - 404 Not Found：被请求的文档不在服务器上
    - 505 HTTP Version Not Supported：服务器不支持请求报文使用的HTTP协议版本

  - 首部行：

    - Connection：是否关闭该TCP连接
    - Date：指示服务器产生并发送该相应报文的日期和时间，该时间是服务器从文件系统中检索到该对象，将该对象插入响应报文，并发送该响应报文的时间
    - Server：指示该报文由什么服务器产生的
    - Last-Modified：只是对象创建或最后修改的日期和时间。对拥有代理服务器的十分重要
    - Content-Length：被发送对象中的字节数
    - Content-Type：实体体中的对象是什么类型的文本

  - 实体体：报文的主要部分，包含了所请求对象本身

#### 2.2.4 用户与服务器的交互：cookie

- HTTP使用了cookie允许沾点对用户进行跟踪，在RFC 6265中定义
- cookie技术有4个组件：
  1. 在HTTP响应报文中的一个cookie首部行
  2. 在HTTP请求报文中的一个cookie首部行
  3. 在用户端系统中保留有一个coolie文件，并由用户的浏览器进行管理
  4. 位于Web站点的一个后端数据库
- cookie可以用于标识一个用户，用户首次访问一个站点时，可能需要提供一个用户标识，在后继绘画中，浏览器向服务器传递一个cookie首部，从而向该服务器标识了用户，因此cookie可以在无状态的HTTP上建立一个用户会话层
- cookie的使用仍具有争议，认为它是对用户隐私的一种侵害

#### 2.2.5 Web缓存

- Web缓存器也叫代理服务器，是能够代表初始Web服务器来满足HTTP请求的网络实体，其拥有自己的磁盘存储空间，并在存储空间中保存最近请求过的对象的副本。
- 可以配置用户的浏览器，使得用户的所有HTTP请求首先指向Web缓存器，一旦某浏览器被配置，每个对某对象的浏览器请求首先被定向到该Web缓存器：
  1. 浏览器创建一个到Web缓存器的TCP连接，并向Web缓存器中的对象发送一个HTTP请求
  2. Web缓存器进行检查本地是否存储了该对象的副本，若有则Web缓存器就想客户浏览器用HTTP响应报文返回该对象
  3. 若Web缓存器中没有该对象，它就打开一个与该对象的初始服务器的TCP连接，Web缓存器则在这个缓存器到服务器的TCP连接上发送一个对该对象的HTTP请求，在收到该请求后，初始服务器向Web缓存器发送具有该对象的HTTP响应
  4. 当Web缓存器收到该对象时，它在本地存储空间存储一份副本，并向客户的浏览器用HTTP响应报文发送该副本
- 在因特网上不是Web缓存器有两个原因：
  1. 可以大大减少对客户请求的响应时间，特别是当客户与Web服务器之间有一个高速连接（常常如此），并且若用户所请求的对象在Web缓存器上，则Web缓存器可以迅速将该对象交付给用户。
  2. 其能大大减少一个机构的接入链路到因特网的通信量，就不必急于增加带宽，因此降低了费用。且能从整体上大大降低因特网上的Web流量，从而改善了所有应用的性能
- 通过使用内容分发网络（Content Distribution Network，CDN），Web缓存器正在因特网中发挥着越来越重要的作用，CDN公司在因特网上安装了许多地理上分散的缓存器，因而使大量流量实现本地化。有多个共享的CDN和专用的CDN

#### 2.2.6 条件GET方法

- 尽管高速缓存能减少用户感受到的响应时间，但存放在缓存器中的对象副本可能是陈旧的
- HTTP协议中有条件GET，允许缓存器证实它的对象是最新的。若请求报文使用GET方法，且其中包含一个If-Modified-Since首部行，则该HTTP报文就是一个条件GET请求报文
- 条件GET方法的操作：
  1. 一个代理缓存器代表一个请求浏览器向某Web服务器发送一个请求报文
  2. 该Web服务器向缓存器发送具有被请求的对象的响应报文，该响应报文中包含了Last-Modified首部行，存储了最后更新时间，代理服务器将该时间存储起来
  3. 代理服务器在适当时间向Web服务器发送条件GET语句，其中If-Modified-Since首部行的值等于上次存储的Last-Modified值，若Web服务器已经被更改了，则需要重新发送对象
  4. Web服务器发送一个响应报文，包含是否被修改的信息，其中不包含对象以免浪费带宽

### 2.3 因特网中的电子邮件

- 因特网电子邮件有三个主要组成部分：
  - 用户代理：允许用户阅读、回复、转发、保存和撰写报文
  - 邮件服务器：电子邮箱体系结构的核心，每个接收方在其中的某个邮件服务器上有一个邮箱，该邮箱管理和维护着发送给接收方的报文
  - 简单邮件传输协议（Simple Mail Trasfer Protocol，SMTP）：使用TCP可靠数据传输服务，其也包含两个部分，运行在发送方邮件服务器的客户端和运行在接受方邮件服务器的服务器端，每台邮件服务器上既运行SMTP的客户端也运行服务器端
- 一个典型的邮件发送过程是：从发送方的用户代理开始，传输到发送方的邮件服务器，再传输到接收方的邮件服务器，然后在这里被分发到接收方的邮箱中。当接收方在他的邮箱中读取该报文时，包含他邮箱的邮件服务器使用用户名和口令来鉴别接收者。发送这的邮箱也必须能够处理接受者的邮件服务器故障，若发送者不能将邮件交付给接收者的服务器，则发送者的服务器在一个报文队列中保持该报文并在以后尝试再次发送，通常每30分钟进行一次尝试，若几天后仍不能成功，服务器就删除该报文并以电子邮件的形式通知发送方

