### 1.1 将源代码编译成托管模块

- 公共语言运行时（Common Language Runtime，CLR）是一个可由多种编程语言使用的 “运行时”，其核心功能（如内存管理、程序集加载、安全性、异常处理、线程同步）可由面向 CLR 的所有语言使用。运行时，只要是面向 CLR 的语言都可以使用 CLR。

- Microsoft 创建了几个面向 “运行时” 的语言编辑器，包括：C++/CLI、C#、Visual Basic、F#、Iron Python、Iron Ruby、IL（Intermediate Language）汇编器。

- 可用支持 CLR 的任何语言创建源代码文件，然后用对应的编辑器检查语法和分析代码，它们的结果都是托管模块。托管模块是标准的 32 位 Microsoft Windows 可移植执行体（Portable Executable，PE32）文件，或标准的 64 位 Windows 可移植执行体（PE32+）文件，它们都需要 CLR 才能执行。

  托管模块的各个部分：

  | 组成部分         | 说明                                                         |
  | ---------------- | ------------------------------------------------------------ |
  | PE32 或 PE32+ 头 | 标准 Windows PE 文件头。若使用 PE32 格式，文件能在 Windows 的 32 位或 64 位版本上运行。若使用 PE32+ 格式，文件只能在 Windows 的 64 位版本上运行。该头还标识了文件类型，包括 GUI、CUI、DLL，并包含一个时间标记来指出文件的生成时间。对于只包含 IL 代码的模块，PE32（+）头的大多数信息会被忽视，若包含本机 CPU 代码的模块，该头包含与本机 CPU 代码有关的信息。 |
  | CLR 头           | 包含使这个模块成为托管模块的信息（可由 CLR 和一些使用程序进行解释）。头中包含要求的 CLR 版本，一些标志，托管模块入口方法（Main）的 MethodDef 元数据 token 以及模板的元数据、资源、强名称、一些标志及其他不太重要的数据项的位置和大小 |
  | 元数据           | 每个托管模块都包含元数据表，主要有两种：描述源代码中定义的类型和成员，描述源代码引用的类型和成员 |
  | IL 代码          | 编译器编译源代码时生成的代码，运行时 CLR 将 IL 编译成本机 CPU 指令 |

  本机代码编译器生成的是面向特定 CPU 架构的代码，而每个面向 CLR 的编译器生成的都是 IL 代码，IL 代码有时称为托管代码，因为 CLR 管理它的执行。

  CLR 还要生成完整的元数据，它是一个数据表集合。一些描述了模块中定义了什么（如类型及其成员），另一些描述了模块引用了什么（如导入的类型及其成员）。元数据是一些老技术（包括 COM 的 “类型库” 和 “接口定义语言”（Interface Definition lLanguage，IDL） 文件）的超集，且和它们不同的是元数据总是包含 IL 代码的文件关联，总是嵌入和代码相同的 EXE/DLL 文件中。编译器同时生成元数据和代码将它们绑定一起，并嵌入最终生成的托管模块，所以元数据和它描述的 IL 代码永远不会失去同步。

  元数据的一些用途：

  - 元数据避免了编译时对原生 C/C++ 头和库文件的需求，因为在实现类型/成员的 IL 代码文件中，已包含引用类型/成员的全部信息，编译器直接从托管模块读取元数据。
  - vs 的 “智能感知” 技术会解析元数据，告诉用户一个类型提供了哪些方法、属性、事件和字段，对方法还能告诉你需要的参数。
  - CLR 的代码验证过程使用元数据确保代码只执行 “类型安全” 的操作。
  - 元数据允许将对象的字段序列化到内存，将其发送给另一台机器然后反序列化，在远程机器上重建对象状态。
  - 元数据允许垃圾回收器跟踪对象生存期。垃圾回收器能判断任何对象的类型，并从元数据知道哪个对象中的哪个字段引用了其他对象。

- 托管程序集总是利用 Windows 的数据执行保护（Data Execution Prevention，DEP）和地址空间布局随机化（Address Space Randomization，ASLR），这两功能用于增强系统的安全性。

- Microsoft 的 C++ 编译器默认生成包含非托管代码的 EXE/DLL模块，并在运行时操作非托管数据，其不需要 CLR 就可以执行。通过指定 /CLR 命令行开关，C++ 编译器能生成包含托管代码的模块。在上面所有 Microsoft 编译器中，只有 C++ 编译器允许同时写托管和非托管代码，并生成到同一个模块中，也是唯一允许同时定义托管和非托管数据类型的 Microsoft 编译器。

### 1.2 将托管模块合并成程序集

- CLR 实际不和模块工作，它和程序集工作。程序集是一个或多个模块/资源文件的逻辑性分组，是重用、安全性、版本控制的最凶啊单元，生成单文件或多文件程序集取决于选择的编译器或工具。
- PE32（+）文件包含了名为清单的数据块，它是元数据表的集合，表中描述了构成程序集的文件、程序集中的文件所实现的公开导出的类型、与程序集关联的资源或数据文件，编译器默认将生成的托管模块转换成程序集，所以对于只有一个托管模块且无资源或数据文件的项目，程序集就是托管模块，生成过程无需执行任何额外的步骤，若要将一组文件合并到程序集中，就必须掌握更多工具及其命令行选项。
- 在程序集模块中还包含了引用程序集有关的信息，这些信息使程序集能够自描述，CLR 能判断为了执行程序集中的代码，其直接依赖对象是什么，所以和非托管组件相比其更容易部署。

### 1.3 加载公共语言运行时

- 检查 %SystemRoot%\System32 目录中是否存在 mscoree.dll 就知道 .NET Framework 是否安装。通过检查 %SystemRoot%\Microsoft .NET\Framework 或 Framework64 的子目录，即可知道安装了哪些版本的 .NET Framework。也可通过 .NET Framework SDK 提供的 CLRVer.exe 列出机器上安装的所有 CLR 版本，还可通过 -all 命令行开关或指定目标进程 ID 列出机器中正在运行的进程使用的 CLR 版本号。

- 若程序集文件只包含类型安全的托管代码，那么在 32 位和 64 位 Windows 上都能正常工作。若开发人员希望代码旨在一个特定版本的 Windows 上运行，如使用不安全的代码或要面向一种特定 CPU 架构的非托管代码进行互操作，这可以使用 C# 编译器提供的 /platform 命令行开关选项，它允许指定最终生成的程序集只能在运行 32 位或 64 位的 Windows 版本的 x86 机器上使用，或只能在运行 32 位 Windows RT的 ARM 机器上使用，不指定具体平台的话默认选项时 anycpu，即可以在任何版本的 Windows 上运行。

  /platform 开关选项对生成模块的影响以及在运行时的影响：

  | /platform 开关       |   生成的托管模块   |      x86 Windows       |       x64 Windows       |     ARM Windows RT     |
  | -------------------- | :----------------: | :--------------------: | :---------------------: | :--------------------: |
  | anycpu               | PE32/任意 CPU 架构 | 作为 32 位应用程序运行 | 作为 64 位应用程序运行  | 作为 32 位应用程序运行 |
  | anycpu32bitpreferred | PE32/任意 CPU 架构 | 作为 32 位应用程序运行 | 作为 WoW64 应用程序运行 | 作为 32 位应用程序运行 |
  | x86                  |      PE32/x86      | 作为 32 位应用程序运行 | 作为 WoW64 应用程序运行 |         不运行         |
  | x64                  |      PE32/x64      |         不运行         | 作为 64 位应用程序运行  |         不运行         |
  | ARM                  |      PE32/ARM      |         不运行         |         不运行          | 作为 32 位应用程序运行 |

- C# 编译器生成的程序集包含的要么时 PE32 头，要么是 PE32+ 头，编译器还会在头中指定要求什么 CPU 架构。Microsoft C# 编译器 1.0 或 1.1 版本生成的程序集包含的是 PE32 头，且没有指定 CPU 架构。加载时 CLR 会认为这些程序只用于 x86，这增加了可执行文件与 64 位系统的兼容能力。

  可执行文件运行时，Windows 会检查文件头。Microsoft 发布了 SDK 命令行实用程序 DumpBin.exe 和 CorFlags.exe，可用它们检查编译器生成的托管模块所嵌入的信息。然后进程的主线程调用 mscoree.dll 中的一个方法，它初始化 CLR，加载程序集，调用其入口方法，随后托管应用程序启动并运行。

  若使用非托管应用程序调用 LoadLibrary 加载托管程序集，Windows 会自动加载并初始化 CLR 以处理程序集中的代码，此时进程已经启动并运行了，而这可能限制程序集的可用性。

### 1.4 执行程序集的代码

- IL 时与 CPU 无关的机器语言，其比大多数 CPU 机器语言都高级，IL 能访问和操作对象类型，提供指令创建和初始化对象、调用对象上的虚方法，直接操作数组元素，提供了抛出和捕捉异常的指令来实现错误处理，可以将其视为面向对象的机器语言。

- 在 Main 方法执行前，CLR 会检测出 Main 代码引用的所有类型，这导致 CLR 分配一个内部数据结构来管理对引用类型的访问，每个类型定义的每个方法都有一个对应的记录项，每个记录项含有一个地址，根据此地址即可找到方法的实现。对这个结构初始化时，CLR 将每个记录项都指向包含在 CLR 内部的一个未编档函数，称为 JITComplier。当首次调用方法时 JITCompiler 函数会被调用，其负责将方法的 IL 函数编译成本机 CPU 指令，由于 IL 是 “即时” 编译的，所以成这个组件为 JITter 或 JIT 编译器。由于已经进行了验证和编译，所以第二次进行调用时会直接执行内存块的代码。方法仅在第一次调用时有损失。

  由于 JIT 编译器会把本机 CPU 指令放入动态内存中，所以多次运行程序同样要再翻译一遍。

  对于大多数应用程序都反复调用相同的方法，程序运行期间只会对性能造成一次性影响，在方法内部花费的时间很可能比花在调用方法上的时间要多得多，所以 JIT 编译造成的性能那个损失并不显著。

- CLR 的 JIT 编译器会对本机代码进行优化，可能花更多时间生成优化代码。C# 编译器开关 /optimize 和 /debug 会影响代码优化：

  - /optimize-，生成的未优化代码中将包含许多 NOP（no-operation）指令，以及跳转到下一行代码指令。vs 利用这些指令在调试期间提供 “编辑并继续” 功能，还可在控制流程指令（如条件、循环、异常处理）上设置断点使代码更容易调试。若使用 /optimaize+ 指令，生成的代码会删除多余的 NOP 和分支指令，代码就很难在调试器单步调试了，且在调试器中执行，一些函数可能无法求值，但优化的 IL 代码变得更小，结果 exe/dll 文件也更小。

  - 指定 /debug(+/full/pdbonly) 开关，编译器才会生成 Program Database（PDB）文件，其帮助调试器查找局部变量并将  IL 指令映射到源代码。

    /debug:full 告诉 JIT 编译器打算调试的程序集，JIT 编译器会记录每条 IL 指令生成的本机代码，可利用 vs 的 ”即时“ 调试功能将调试器连接到正在运行的进程，并方便的对源代码进行调试。不指定则 JIT 编译器默认不记录 IL 与本机代码的联系，使 JIT 编译器运行的稍快，内存稍少。若进程没在 vs 中关闭 ”在模块加载时取消 JIT 优化（仅限托管）“ 选项，否则用 vs 启动则会强迫 JIT 编译器记录 IL 与本机代码的联系。

- 托管代码相较于非托管代码的优势：

  - JIT 编译器能判断应用是否运行在 Intel Pentium 4 CPU 上，并生成相应的本机代码来利用 Pentium 4 支持的任何特殊指令，而非托管应用程序通常是针对具有最小功能集合的 CPU 编译的，不会使用能提升性能的特殊指令。
  - JIT 编译器能判断一个特定的测试（如条件判断语句块）在它运行的机器上是否总是失败，若是则不会为其生成任何 CPU 指令，最终代码变得很小，执行更快。
  - 应用程序运行时，CLR 可以评估代码的执行，并将 IL 重新编译成本机代码，重新编译的代码可以重新组织，并根据该评估减少不正确的分支预测。（本书版本还不支持）

- .NET Framework SDK 配套提供的 NGen.exe 工具，其将程序集的所有 IL 代码编译成本机代码，并保存到一个磁盘文件中，运行时加载程序集 CLR 会判断是否存在预编译版本，这可以避免运行时编译。但 NGen.exe 对最终执行环境的预设很保守，所以不会像 JIT 编译器生成的会进行高度优化

- System.Runtime.ProfileOptimization 类，其会导致 CLR 检查程序运行时哪些方法被 JIT 编译，结果被记录到文件中，程序再次启动时，若在多 CPU 机器上会利用其他线程并发编译这些方法，使应用程序运行的更快。

#### 1.4.1 IL 和验证

- IL 基于栈，它的所有指令都要将操作数压入一个执行栈，并从栈弹出结果，由于 IL 没有提供操作寄存器的指令，所以可以很容易创建新的语言和编译器，生成面向 CLR 的代码。

- IL 指令是 “无类型” 的，当指令执行时，它判断栈中的操作数的类型，并执行恰当操作

- 将 IL 编译成本机 CPU 指令时，CLR 执行一个验证的过程，它会检查高级 IL 代码，确定代码所做的一切都是安全的，托管模块的元数据包含验证过程要用到的所有方法及类型信息。

  Windows 每个进程都又自己的虚拟地址空间，因为应用程序完全可能读写无效的内存地址。通过验证托管代码，可确保代码不会不正确的访问内存，不会干扰到另一个应用程序的代码，这样就可以将多个托管应用程序放到同一个 Windows 虚拟地址空间中运行，这可以用一个进程运行多个应用程序，减少进程数，从而增强性能减少所需资源。

#### 1.4.2 不安全的代码

