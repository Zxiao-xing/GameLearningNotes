- 批处理是一个非常通用的术语，描述了讲大量任意数据块组合在一起并将它们作为单个大数据块进行处理的过程，这对于 CPU 特别是 GPU 是非常理想的，可以使用多个内核同时处理多个任务

- Unity 中的批处理通常指动态批处理和静态批处理，它们本质上是几何体合并的两种不同形式，用于将多个对象网格数据合并在一起，并在单一指令中渲染它们，而不是单独准备和绘制每个几何体。

  将多个网格批处理为单个网格是可以实现的，因为没有规定网格对象必须是现需的几何体，渲染管线可以接受一系列没有共同边的低昂点。

### 3.1 Draw Call

- Draw Call 只是一个从 CPU 发送到 GPU 中用于绘制对象的请求，Unity 中有时也称为 Set Pass Call。在请求 Draw Call 之前需要完成一些工作：

  - 首先网格和纹理数据必须从 CPU 内存推送到 GPU 内存，这通常发生在场景初始化期间

  - 接着 CPU 必须配置处理对象所需要的选项和渲染特性，为 GPU 做好准备。在渲染对象前，必须为准备管线渲染而配置的大量设置统称为渲染状态，若这些状态没有发生变化，则 GPU 将为所有传入的对象保持相同的渲染状态。

    更改渲染状态是一个耗时的过程，在如 GPU 这样的大规模并行系统中，必须在修改渲染状态之前一直等待，直到所有当前的作业达到同一个同步点为止，然后需要重新启动所有作业。因此请求改变的渲染状态越少，Graphics API 越能更快的处理请求。

    可以触发渲染状态同步的操作包括但不仅限于：推送一张新纹理到 GPU 中，修改着色器、照明信息、阴影、透明度、其他任何图形设置。

  - 一旦设置了渲染状态，CPU 就决定绘制哪个网格，使用什么纹理和着色器，以及基于对象的位置、旋转、缩放决定在何处绘制独享，然后发送指令到 GPU 以绘制它。

- 批处理提升此过程的性能在于，新的 Draw Call 不一定意味着必须配置新的渲染状态，若两个对象共享完全相同的渲染状态信息，则 GPU 可以立即开始渲染新对象，这消除了由于同步渲染状态而浪费的时间，减少了推入 Command Buffer 中的指令数，减少了 CPU 和 GPU 的工作负载。但渲染管线不够只能，意识不到在重复写入完全相同的渲染状态，绘制相同的网格。

### 3.2 材质和着色器

- Unity 中渲染状态本质上是通过材质呈现给开发者的，所以若想要最小化渲染状态修改的频率，可以减少场景中使用的材质数量，CPU 每帧将花费更少的时间生成指令并传输给 GPU，且 GPU 不需要经常停止重新同步状态变更。

  材质是着色器的容器，着色器和材质的关系是一对一。若要对一个网格使用多个着色去，需要将多个材质赋予该网格的不同部位。

### 3.3 Frame Debugger

- Frame Debugger 用户界面的左边面板带有 GPU 指令列表，右边面板包含了详细信息。其中左边面板的 Drawing 部分列出了场景中所有的 Draw Call，若单击一个 Draw Call 项就会显示标签为 ”Why this draw call can't be batched with the previous one“，大多数情况下，下方的解释文本说明了哪个条件没有满足批处理（至少是检测到的首个条件）以及有什么调试批处理的行为的有用方法。

### 3.4 动态批处理

- 动态批处理的优势：
  - 批处理是在运行时产生的（动态产生）
  - 批处理中包含的对象在不同的帧之间可能有所不同，这取决于哪些网格在主摄像机视图中当前是可见的（处理内容是动态的）
  - 能在场景中运动的对象也可以进行批处理（对动态对象有效）
- 对网格进行成功动态批处理的需求列表可以在 Unity Manual 的 DrawCallBatching 文档中找到。Unity2017 的需求为：
  - 所有网格实例必须使用相同的材质引用
  - 只要 ParticleSystem 和 MeshRenderer 组件进行动态批处理，SkinnedMeshRenderer 和所有其他可渲染的组件类型不能进行批处理
  - 每个网格至多 300 个顶点
  - 着色器使用的顶点属性不能大于 900
  - 所有网格实例要么使用等比缩放，要么非等比缩放，但不能两者混用
  - 网格实例应该引用相同的光照纹理文件
  - 材质的着色器不能依赖多个过程
  - 网格实例不能接受实时投影
  - 整个批处理中网格索引的总数优先，这与所用的 Graphics API 和平台有关，一般索引值在 32~64k 之间

#### 3.4.1 顶点属性

- 着色器中，每个顶点使用的属性数据越多，900 个属性预算就消耗的越快，从而减少了网格允许拥有的顶点数量。
- 查看网格的原始数据文件，其中包含的顶点属性信息会比 Unity 载入内存的少，因为引擎会将网格数据从几个原始数据结构转化为内部格式，因此不要假设 3D 建模工具提供的顶点属性数量是最终的数量，验证属性书的最好方式是将网格对象拖到场景中，在 Project 窗口中找到 MeshFilter 组件，在 Inspector 窗口的 Preview 子区域查看 verts 值。

#### 3.4.2 网格缩放

- 实数缩放通常是镜像场景中网格的快速方式，可以避免创建和导入完全不同的网格，用来生成仅沿着某个轴翻转的对象。使用负数缩放会对动态批出理产生奇怪的效果：
  - 只对网格的 1 个或 3 个轴进行负数缩放的网格会放到不同的动态批处理中，这之和负数值的个数是奇数还是偶数有关。
  - 对象的渲染顺序可以决定什么网格可以进行批处理，若先前的对象出现在与当前对象不同的批处理组中，则无法对齐进行批处理。

#### 3.4.3 动态批处理总结

- 要渲染当量简单网格时，动态批处理是非常有用的工具。
- 若阻止两个对象动态批处理的唯一条件是它们使用了不同的纹理，就应该花点时间和精力合并纹理（图集），并重新生成网格 UV 以便进行动态皮锤，这可能会牺牲纹理的质量或使纹理文件变大
- 动态批处理可能对性能造成损害的唯一情况是，一个场景中有数百个简单对象，而每个批处理中只有几个对象，该情况检测和生成多个小批处理组的开销成本可能比每个网格单独执行 Draw Call 所节省的时间要多。

### 3.5 静态批处理

- 静态批处理在几个方面类似于动态批处理，如对什么对象进行批处理取决于运行时它对相机是否可见。它们来那个之间重要的区别是，静态批处理只处理标记为 Static 的对象。
- 静态批处理系统的要求：
  - 网格必须标记为 Static（具体是指 Batching Static）
  - 每个被静态批处理的网格都需要额外内存
  - 合并到静态批处理中的顶点数量是有上限的，随着 Graphics API 和平台的不同，一般为 32~64k。
  - 网格实例可以来自任何网格数据源，但必须使用相同的材质引用

#### 3.5.1 Static 标记

- 单击 GameObject 的 Static 选项旁的下小三角形，会出现一个StaticEditorFlags 下拉框，可以为不同的 Static 处理过程修改对象的行为。该标记的缺点是不能随便修改对象的父类，且任何想要进行静态批处理的对象都不能通过任何移动的方式、旋转、缩放。

#### 3.5.2 内存需求

- 静态批处理的额外内存需求取决于批处理的网格中复制的次数，它在工作时将所有标记为 Static 的可见网格数据复制到一个更大的网格数据缓冲中，并通过一个 Draw Call 传到渲染管线中同时忽略原始网格。若进行静态批处理的网格都各不同，则与正常渲染对象相比不会增加内存使用量，因为内存空间量是相同的，但若是相同的，则原来引用的相同的网格数据，但静态批处理需要把数据复制到一个大的缓冲区，所以该引用会丢失，因为原始网格的每个副本都会复制到缓冲区中，每个副本带着不同的数据集以及附着到顶点位置的硬编码转换，若没有正确使用静态批处理将导致一些严重的内存消耗和性能问题

#### 3.5.3 材质引用

- 共享材质引用是减少渲染状态变更的一种方式，有时静态批处理需要更多材质的网格，该情况下所有使用不同材质的网格都会划分到各自的静态批处理组，每个组使用不同的材质。该要求缺点是静态批处理渲染所有静态网格时，使用 Draw Call 数量最多只能等于所需的材质数量。

#### 3.5.4 静态批处理的警告

- 静态批处理有几个缺点：

  - Draw Call 减少了但不能直接在 Stats 窗口看到，要在运行时才能看到。在 Edit 模式下静态批处理没有生效，因此手动测试之前难以确定静态批处理提供了什么优势，应该使用Frame Debugger 来验证静态批处理是否正确生成以及是否包含了预期的对象。

    若在项目后期才开始使用该特性，需要花费大量的时间启动、调整、重启动场景，以确保期待节省的 Draw Call。

    静态批处理创建工作并不是完全琐碎的，若有许多批处理需要创建，或有许多大型对象要批处理，那么场景初始化时间可能会显著增加。

  - 在运行时向场景中引入标记为 Batching Static 对象不能自动包含进静态批处理，因为这需要重新计算网格和与管线渲染同步之间造成巨大的运行时开销。若需要动态实例化或使用叠加方式加载场景，则可以使用 StatciBatchUtility.Combine() 方法控制静态批处理，它有两个重载形式：一个需要提供根 GameObject，该对象中所有带网格的子 GameObject 对象都会转换到新的静态批处理组中，若使用了多个材质就会创建多个组；另一种需要提供 GameObject 列表和一个根 GameObject，会自动将列表中的对象作为根 GameObject 的子节点，以相同方式生成静态批处理。若有许多顶点要恒冰则该操作将非常昂贵，它也不会将给定的网格与任何预先存在的静态批处理合并在一起，因此无法通过实例化或叠加加载静态网格来减少 Draw 调用

    注意，若调用该方法前 GameObject 不是 Static，而网格是 Static，则可能导致其 Collider 组件和其他重要对象被移动但网格依然留在原处。

#### 3.5.5 静态批处理总结

- 静态批处理与动态批处理相比，它可以用于不同的形状和巨大尺寸的网格

