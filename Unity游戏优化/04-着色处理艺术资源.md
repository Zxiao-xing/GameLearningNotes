### 4.1 音频

- 产生音频瓶颈的缘由多种多样，多度压缩、过多音频操作、过多活动的音频组件、低效的内存存储方法和访问速度，都是导致内存和 CPU 性能低下的原因

#### 4.1.1 导入音频文件

- 在 Project 窗口选中导入的音频文件时，Inspector 窗口将显示多个导入设置，包括加载行为、压缩行为、质量、采样率、是否支持双声道音频。很多音频导入选项可以基于每个平台配置，允许在不同的目标平台上自定义行为。

#### 4.1.2 加载音频文件

- 音频文件最初的打包为与应用程序捆绑在一起的二进制数据文件，其位于设备的硬盘上或互联网上，加载音频数据仅仅意味着将其拉入主存，以便音频解码器进行处理，然后将数据转换为音频信号送到耳机或扬声器。

- 通过 3 种设置可以指定音频文件的加载方式：

  - Preload Audio Data：决定音频数据是否在初始化期间自动加载，禁用该选项代表在场景初始化期间跳过音频文件资源的加载，将该活动推迟到需要使用音频文件时，即调用相应的播放函数（可以通过 AudioClip.LoadAdudioData() 加载音频，但也是同步的）。禁用让场景初始化更快，但也让播放时 CPU 需要立即访问磁盘检索文件，将其加载到内存然后解压并播放，这是一个同步操作，会阻塞主线程直到完成。

    无论是否选择提前加载都可以 使用 AduioClip.UnloadAudioData() 卸载数据。

  - Load In Background：决定加载活动是在完成之前阻塞主线程还是后台异步加载。启用该选项后对 AddioClip.LoadAudioData() 的实际调用将立即完成，但在单独线程上完成加载前文件还没准备好用于播放，可以通过 AudioClip.loadState 属性来查看 AudioClip 组件目前的加载状态，若没有提前加载的话，调用播放函数仍需要先加载到内存中，这使音频开始播放时间与播放函数调用之间有一定延迟。-

  - Load Type：定义将什么类型的数据拉入内存，以及一次拉入多少数据，其有三个选择：

    - Decompress On Load：压缩磁盘上的文件以剑圣空间，并在首次加载时将其解压缩到内存中。解压文件需要一段时间，会导致加载过程中的额外开销，但会减少播放音频文件时所需的工作量。
    - Compressed In Memory：加载音频时只是将其直接从磁盘复制到内存中，当播放音频文件时才会对齐进行解压，这将在播放音频剪辑时牺牲运行时 CPU，但在音频剪辑保持休眠状态时提高了加载速度，减少了运行时内存消耗。该选项适合频繁使用的大型音频文件，或在内存消耗上遇到难以执行的瓶颈且原因牺牲一些 CPU 周期来播放音频剪辑。
    - Streaming：在运行时加载、解码、播放文件，具体做法是逐步将文件推到一个小缓冲区，缓冲区中一次只存在文件的一小部分数据。该方法对特定音频剪辑使用的内存量最小，但运行时 CPU 使用的内存量最大。由于问价你的每个回放实例都要生成自己的缓冲区，因此它在多次引用音频剪辑时会导致内存中同一个音频剪辑的多个副本必须单独处理。该选项最好用于定期播放的单实例音频剪辑，该剪辑不需要与自身的其他实例或与其他流式音频剪辑重叠。

    默认情况下，启用 Preload Audio Data，禁用 Load In Background，使用 Decompress On Load 的加载类型

#### 4.1.3 编码格式与品质级别

- Unity 支持 3 种音频剪辑编码格式，在 Inspector 窗口查看音频剪辑的属性时，由 Compression Format 选项决定：

  - Compressed：该选项真正文本内容会随着平台的不同而不同，独立引用程序和其他非移动平台将文件转换为 Ogg Vorbis 格式，而移动平台使用 MP3 格式。有一些平台总是使用特定类型的亚索，如 PS Vita 的 HEVAG，XBox One 的 XMA 和 WebGL 的 AAC。该格式使小文件的质量低于 PCM 但优于 ADPCM，待机是使用额外运行时 CPU，大多数情况下都是使用该格式。只有该选项才能在不影响文件采样率的情况下更改质量，允许自定义压缩算法的结果质量级别，通过文件大小调整质量。

  - PCM：一种无损的、未压缩的银屏格式，提供接近模拟音频的效果，它以更大的文件换取更高的音频质量，适用于短暂且需要高清晰度的音效。
  - ADPCM：在大小和 CPU 消耗方面都比 PCM 高效的多，但压缩会产生相当大的噪声，若将其作为具有大量混乱的短声音效果则可以隐藏噪声。

- Inspector 面板中会显示当前所选格式的统计信息，显示了压缩所节省的磁盘空间预估值，第一个值是原始文件大小，第二个值是磁盘上大小开销，第三个值是压缩后大小与原大小的比率。这个成本节省值仅适用于当前选定的平台和最近应用的设置，要确保切换到目标平台。

#### 4.1.4 音频性能增强

**最小化活动音源数量**

- 由于每个播放中的音频源消耗特定数量的 CPU，因此禁用场景中冗余的音频源可以节省 CPU 周期。一种方法是限制可以同时播放的音频剪辑的实例数，这涉及通过一个中介发送音频播放请求，该中介控制着音频源从而对一个音频剪辑可以同时播放的实例数设置硬性的上限。

  Unity Asset Store 中几乎所有可用的音频管理资产都实现了某种类型的音频限制功能（通常称为音频池），这是以最低的质量成本最小化过度音频播放的最佳折中方案，这些工具通常提供许多更微妙的性能增强效果。

  当设计环境音效时仍然需要放在场景中特定的位置，使其具有伪三维效果，此时音频池系统可能不是理想的解决方案。通过减少音频源的总数来限制对环境音效是最好的，要么是移除其中的一些音效，要么减少到一个更大声的音频源，该方法会影响用户体验的质量，声音似乎来自一个源而不是多个。

**为 3D 声音启用强制为单声道**

- 在立体声音频文件上启用 Force to Mono 设置会将两个音频通道的数据混合到一个通道中，文件的总磁盘和内存空间使用量有效降低了 50%，一般不要给二维音效启用该选项，二维音效通常用于创建特定的音频体验。在两个通道实际相同的 3D 位置音频剪辑上可以启用此选项以节省一些空间。若不需要立体声效果也可以强制单声道。

**重新采样到低频**

- 将导入的音频文件重新采样到较低的频率将减小文件和运行时内存占用，可以将音频文件的 Sample Rate 设置为 Override Sample Rate，通过 Sample Rate 选项配置采样率。大多数情况下，较低的设置可以减少文件的大小而不会明显降低质量，22050Hz 是源于人类语音和古典音乐的一个常见采样率，有些声音效果甚至可以更低

**考虑所有的压缩格式**

- 每个压缩格式有各自的优缺点，在适当的情况下可以对不同的文件使用不同的编码格式，在内存占用、磁盘占用、CPU 使用、音频质量方面做出一些妥协。考虑在同一个应用程序中使用所有这些文件，并设计出一个适于所使用的音频文件类型的系统，就不需要单独处理每个文件。

**注意流媒体**

- Streaming 加载类型的有点是运行内存成本低，但它需要运行时硬盘访问，使用该选项分层或转换的音乐剪辑可能会遇到严重的问题，还应该避免一次传输多个文件，因为它可能在磁盘上造成大量缓存丢失。

**通过混音器组应用过滤效果以减少重复**

- 过滤效果可用于修改通过音频源播放的音效，并可通过 FilterEffect 组件能完成，每个单独的过滤效果都需要消耗一定的内存和 CPU，这可以节省磁盘空间同时保持音频播放的多样性，因为一个文件可以通过一组不同的过滤器进行调整以产生不同的声音效果。由于有额外开销，在场景中过度使用过滤器效果会导致性能上的严重后果，更好的方法是利用 Unity 的音频混音器实用程序（Window | Audio Mixer）生成的通用过滤效果模板，多个音频源可以引用这些模板以最小化内存开销。

**谨慎使用远程内容流**

- 可以使用 Unity 通过 Web 动态加载游戏内容，这是减少应用程序磁盘占用的一种有效方法。

  Unity5 WWW 类提供了 audioClip 属性，若 AudioClip 对象是通过 WWW 对象下载的音频文件，则该属性用于访问 AudioClip 对象，和其他 WWW 资源获取方法一样，访问时将分配一个全新的 AudioClip 资源，一旦不再需要次资源必须使用 Resources.UnloadAsset() 方法释放它，因为它不是托管资源不会在引用丢失后自动释放。

  Unity2017 中 WWW 已被 UnityWebRequest 类替代，使用了新的 HLAPI 和 LLAPI 网络层，这个类提供了各种实用程序来下载和访问以文本文件为主的内容。基于多媒体的请求应通过 UnityWebRequestMultimedia 辅助类发送，通过 UnityWebRequestMultimedia.GetAudioClip() 请求 AudioClip()，调用 DownloadHandlerAudioClip.GetContent() 在下载完成后取出音频内容。该 API 旨在更有效的存储和提供请求的数据，通过 DownloadHandlerAudioClip.GetContent() 多次重新获取音频剪辑不会导致额外的分配，只返回对最初下载的音频剪辑的引用。

**考虑用于背景音乐的音频模块（Audio Module）文件**

- 音频模块文件也称为音轨模块（Tracker Module），是节省大量空间且没有任何明显质量损失的绝佳方式。Unity 中支持的文件扩展名有 .it、.s3m、.xm、 .mod。在普通的音频格式中，音轨模块是以位流的形式读取的，必须在运行时解码以生成特定的声音，而音轨模块包含许多的小的、高质量的样本，并将这个音轨组织成类似音乐表的形式，定义每个样本的播放时间、位置、音量、音高以及特效，这样可以保持高质量的采样的同时显著节省占用的空间大小。

### 4.2 纹理文件

- 纹理只是一个图像文件，一个数据的大列表。精灵是网格的 2D 等价物，通常只是一个由一对三角形合并的四边形，用于渲染面向当前相机的平面。精灵表是在一个大纹理文件内大量独立图像的集合，通常用于包含 2D 角色通话，这些文件可以用如 Unity 的 Sprite Atlas 工具进行切分。

#### 4.2.1 纹理压缩格式

- 纹理的 Texture Type 设置决定什么选项是可见的，特别是对于其中的 Advanced 下拉框中的选项，并不是所有导入选项都能用于所有的纹理类型，因此最好设置该选项以明确纹理的目的。

- 可以以多种常见格式导入纹理文件，但应用程序中内置的实际压缩格式可以根据给定平台的 GPU 从很多不同的纹理压缩格式中选择理想适配的一种。这些格式表示组织纹理信息的不同方式，包括每个通道的不同位数、通道的总位数、是否包含 alpha 通道、打包数据的方式（正确的类型允许 GPU 进行高效内存访问）

- 修改压缩的简单方式是使用 Compression 纹理导入选项中的如下其中一项：

  - None：不进行压缩，最终纹理会对导入的文件类型进行格式化，但会选择一种不压缩的格式，品质没有损失或损失很小，但纹理文件较大
  - Low Quality
  - Normal Quality
  - High Quality

  下面三种选项会由 Unity 根据平台不同自动选择压缩格式，这些具体格式可以在 Manual 的 class-TextureImporterOverride 中找到。Unity 选择的压缩格式可以被覆盖，但可用的选项随平台的不同而不同，因为每个平台有最适合自己的自定义格式，在 Inspector 面板中点击到对应的设备图标中，然后点击 Override for xxx 即可调整。

  Use Crunch Compression 选项是在 DXT 压缩格式智商应用额外级别的有损压缩，会在选择除 None 之外的其他格式出现，该设置可以节省更多空间但可能有明显压缩失真。

#### 4.2.2 纹理性能增强

**减小纹理文件大小**

- 给定的纹理文件越大，推送纹理所消耗的 GPU 内存带宽就越多，若每秒推送的总内存超过图形卡的总内存带宽就会产生瓶颈，因为下一次渲染过程开始之前 GPU 必须等待所有纹理都上传完毕。

  为确定是否在内存带宽存在瓶颈，一个简单的测试时降低游戏中最丰富、最大的纹理文件的分辨率并重启场景，若帧速率突然提高，则程序很可能收到纹理吞吐量的限制。

**谨慎的使用 Mipmap**

- Mipmap 通过提前生成相同的纹理的低分辨率替代品，保证占据相同的内存空间，运行时 GPU 根据透视图中的表面大小选择对应的 Mipmap 级别。

  Unity 中通过开启 Generate Mip Maps 设置，自动处理纹理的低分辨率副本生成，通过高质量重采样和过滤方法生成的，而不是运行时生成。其生成有几个选项，可以影响生成的品质级别，因此需要一些微调以获取高质量的 MipMap 集合。这些纹理会打包到一起节省空间，最终的纹理文件比原始图像大 33%，这将消耗一些磁盘空间和用于上传到 GPU 的带宽。

- 将 Scene 窗口的 Draw Mode 设置切换为 Mipmaps 可以观察应用程序中某些时刻使用了哪个 Mip Map 级别，在玩家的当前视图中，若纹理大于它们的合适大小，纹理就以红色高亮显示，而若纹理太小，则会以蓝色高亮显示

- 若纹理一直和主相机保持固定的距离（如 2D 游戏、UI），则不会使用 Mipmap，此时开启 Mipmap 只是对空间的浪费。若一个纹理总是解析为相同的 Mipmap 级别（如一直出现在玩家周围的对象），则明智的做法是简单的缩小纹理

**从外部管理分辨率的降低**

- Unity 做了很多努力让很多工具尽可能易于使用，并允许将项目文件从外部工具导入项目的工作空间中，它们通常很大且拆分为多图层的图像。Unity 自动从文件的内容生成引擎后续可以使用的纹理文件

  问题是 Unity 的自动纹理生成和压缩技术从这些文件中会引入走样，可能不如使用纹理编辑工具生成的效果好，可能会缩小图像的比例，从而通过走样造成失真，但为了保持预期的质量水平，导入比所需分辨率更高的图像文件就可以解决该问题，若首先通过外部应用程序缩小图像的比例走样就可能比较少，且可以用较低分辨率打到可接受的质量水平同时消耗更少的磁盘和内存空间。

- 可以习惯性避免在 Unity 项目中使用从外部工具导入项目的工作空间，或只是偶尔执行一些测试，以确保不会因为使用分辨率比实际所需更高的纹理而浪费文件大小、内存和GPU 内存带宽。

**调整 Anisotropic Filtering 级别**

- Anisotropic Filtering 是一项在非常倾斜的角度观察纹理时提升纹理品质的特性，应用于纹理的强度可以通过 Aniso Level 手动修改，也可以在 Edit->Project->Quality 设置内使用 Anisotropic Textures 选项全局启动/禁用该特性。

  该特性很昂贵，若场景中一些纹理肯定不会从倾斜的角度看则可以安全的禁用，也可以调整强度在品质和性能之间找到平衡点。

**考虑使用图集**

- 图集将许多较小的、独立的纹理合并到一个较大的纹理文件中，从而最小化材质的数量，因此减少 Draw Call 的数量，这是利用动态批处理的有效方法。其需要做的额外工作就是修改网格或精灵对象的 UV 坐标，只采样大纹理文件中所需的部分。若合并纹理文件的分辨率和所有合并的图像相同，就不会有品质损失，内存消耗也会相同，且由于推送到 GPU 的数据是一样的，图集不会减少内存带宽消耗。

- 图集的缺点主要是开发时间和工作流成本，要彻底检查现有的项目才能使用图集，只需要花费大量的精力。还需要注意纹理文件的生成，这对于目标平台来说可能太大了，一些设备对纹理的大小有一个相对较低的限制，这些纹理可以拖到 GPU 的最低内存缓存中，若打包到图集中的纹理文件太大则必须将其分解为更小的纹理，以适应目标内存空间。若设备的 GPU 每次执行 Draw Call 时都需要雷子图集不同部分的纹理，那么不仅会造成大量缓存丢失，还可能阻塞内存带宽，因为纹理总是从 VRAM 的较低级别缓存中提取。

- 图集在 UI 元素和包含许多 2D 图形的游戏中应用的一种常见策略，当开发移动游戏时，Draw Call 会成为最常见的瓶颈，所以该技术很有用。若创建了很多低分辨率的纹理，则可以将此技术应用到 3D 网格上，若 3D 游戏具有简单的分辨率或是扁平着色的低多边形风格，都可以这种方式使用图集。

  由于动态批处理效果只影响非动画的网格，因此不要将动画角色的纹理文件合并到图集，GPU 需要将每个对象的骨骼乘以当前动画状态的变换，意味着需要为每个橘色进行独立的计算，因此只有处于便利和节省空间的考虑才应为动画角色合并纹理。

- 通常来说，若移动游戏采用非常简单的 2D 艺术风格，就可能不需要使用图集。若尝试使用高质量的资源或任何类型的 3D 图形，则应该尽可能在开发时集成图集，因为很可能项目很快就达到纹理吞吐量的限制，甚至可能需要对每个平台和每个设备做优化以吸引更广泛的受众。应该仅在 Draw Call 数量超过硬件可接受合理范围时才考虑将图集应用到高质量的桌面游戏中，低品质的桌面游戏也可能避免使用图集，因为 Draw Call 很可能不是最大的性能瓶颈。

**调整非方形纹理的压缩率**

- 纹理文件通常以正方形、2 的 n 次幂的格式保存。一些 GPU 需要方形的格式，因此 Unity 将自动扩展纹理到额外的空白处进行补偿，以适应 GPU 期望的格式，这将消耗额外的内存带宽，将本质上用不到和没用的数据推送到 GPU。其他 GPU 可能支持非 2 的 n 次幂的纹理，但该纹理的采样可能比方形更慢。

- 避免非正方形和非 2 的 n 次幂的纹理，若图形可以放到 2 的 n 次幂的方形纹理中，不会由于挤压、拉伸而导致品质下降太多，就应该做出这些修改以获得更好的 CPU 和 GPU 性能。

  Unity 中通过纹理文件的 Non Power of 2 导入设置，可以自定义该缩放行为，但因为这是一个自动过程，可能不会带来期望的图形质量。

**Sparse Textures**

- Sparse Textures 也称为 Mega-Textures 或 Tiled-Textures，提供了一种运行时从磁盘传输纹理数据流的方式，它将许多纹理组合成一个巨大的纹理，该文件太大以致于无法作为一个纹理文件加载到图形内存中。该技术主要成本是文件大小需求和潜在的连续磁盘访问，若小心处理，Sparse Texturing 在场景质量和内存节省方面都会有很好的效果。该技术需要专业的硬件和平台支持，且难以实现，所以没有广泛采用。

**程序化材质**

- 程序化材质也称为 Substances 是一种在运行时通过使用自定义数学公式混合小型高质量的纹理样本，通过程序化方式生成纹理的手段，它的目标是在初始化期间以额外的运行时内存和 CPU 处理为代价，极大的减少了应用程序的磁盘占用，以便通过数学操作而不是静态颜色数据来生成纹理。其对于想通过图形逼真度进行竞争的移动游戏很重要。在 Manual 的 ProceduralMaterial 中可以查看相关信息。

**异步纹理上传**

- Read/Write Enable 选项，默认情况下是禁用的，禁用的好处是可以使用 Asynchronous Texture Uploading 特性，纹理会从磁盘异步上传到 RAM 中，且当 GPU 需要纹理数据时，传输发生在渲染线程而不是主线程，纹理会推送到环型缓冲区中，一旦缓冲区中包含新数据就会持续不断的推送到 GPU，若没有新数据就会提前退出并等待，直到请求新的纹理数据。这减少了每帧准备渲染状态所花费的时间，允许将更多的 CPU 资源花在游戏玩法、物理引擎等逻辑模块中。有时怡然在主线程中花费时间准备渲染装填，但将纹理上传任务移到一个独立线程，节省了主线程大量的 CPU 时间。

  开启该选项本质上是告诉 Unity，想要随时读取和编辑该文李，暗示着 GPU 需要随时刷新对它的访问，因此禁用该纹理的异步上传功能，所有上传任务必须在主线程执行。

- 由于异步纹理上传特性仅适用于明确导入到项目中且在构建时存在的纹理，仅在纹理打包到可流式传输的特殊资源中才会生效，所以任何通过 LoadImage 生成的纹理，包括隐含该函数调用的，从外部位置导入或下载纹理，通过 Resources.Load 从 Resources 文件夹加载纹理都不会转换为可流式传输的内容，所以无法使用该特性

- 异步纹理上传特性允许花费的时间上限和 Unity 为了推送要上传的纹理而是用的循环缓冲区总大小是可以调整的，在 Edit->Project Settings->Quality->Other 设置，Async Upload Time Slice 设置期望 Unity 在渲染线程中花费在异步纹理上传的最大毫秒数，Async Upload Buffer Size 设置缓冲区大小，该缓冲区会根据需要扩展大小，但这通常比较昂贵，所以若提前知道大小，可以设置为期望大小的最大值，以避免重新调整缓冲区。

### 4.3 网格和动画文件

