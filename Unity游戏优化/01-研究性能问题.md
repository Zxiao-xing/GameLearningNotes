### 1.1 Unity Profiler

- 通常有两种使用 Profiler 工具的方法：

  - 指令注入（instrumentation）：通常意味着通过观察目标函数调用行为、在哪里分配了多少内存来观察应用程序的内部工作情况，这通常会得到当前执行情况的精确图像并可能找到问题根源，但会带来性能损耗。

    在 Unity 应用程序在开启 Build Settings->Development Build 后编译，会启用附加的编译标志，导致应用程序在运行时生成特殊事件，会被分析器记录并存储。但是由应用程序承担所有额外工作负载，将在运行时导致额外的 CPU 和内存开销。

    若应用程序通过 Unity 编辑器进行分析，则会消耗更多的 CPU 和内存，从而确保编辑器更新界面、渲染额外窗口、处理后台任务，这在比较大的项目中有时会导致严重不一致的行为。

  - 基准分析（benchmarking）：对应用程序进行一次浮光掠影般的体验，在游戏运行于目标硬件上的期间手机一些基本数据，执行测试场景。测试用例可以是只要几秒的简单玩法、不同场景的切换、通关部分关卡等，该活动是对用户可能体验到的东西有一个大致的感觉，在性能变差时持续关注一段时间。感兴趣的一些重要指标是 FPS、总体内存消耗、CPU 活动的行为方式找到其中较大峰值，有时还有 CPU/GPU 温度。

  只有在基准分析表明需要进一步分析之后才应该更深入的研究注入的指令，

  这两个术语通常可以互换。

- 有时候 Editor 计算操作结果的速度比独立应用程序快，这在处理序列化数据如音频文件、预制块、Scriptable Object 特别常见，因为编辑器缓存以前导入的数据，使其比实际应用程序更快的访问这些数据。

### 1.2 通用的性能分析检查方法

- **验证目标脚本是否出现在场景中**

  当期待看见的脚本操作没有出现时，在 Hierarchy 窗口的文本输入框中输入 “t:脚本名” 即可搜索所有挂载该脚本以及脚本的派生类的物体，查找目标物体是否挂载该脚本，并检查相应脚本是否启用

- **验证脚本执行次数是否符合预期**

  当查看 Profile 数据，某些 MonoBehaviour 方法执行的次数或者时间超过预期，需要进行该检查。有可能是在场景文件创建对象的次数或者代码中实例化对象的次数比预期多，问题可能来源于调用了冲突或重复的代码，产生性能瓶颈，在运行中检查该脚本的数量，若短列表显示的组件数比预期的多或者少，最好编写一些初始化代码，或自定义编辑器辅助函数为关卡设计师显示警告，防止这种情况发生

- **验证事件的顺序**

  - Unity 应用程序主要执行从本机代码到托管代码的一系列回调（如 Awake 等函数），负责处理游戏循环（这并非像控制台应用程序，有一个程序起点，然后通过 while 循环渲染游戏），在相同类型的事件发生时，无法确定其执行顺序。不要假设这些回调的执行顺序，它们可能在任何时候中断。若在确定事件的实际顺序时遇到困难，使用带IDE的逐步调试器来处理或通过Debug.Log 打印日志语句。


  - 协程通常用来编写一些事件序列的脚本，何时触发取决于 yield 类型，最不可预测的是 WaitForSeconds yield类。Unity 引擎是不确定的，即使在相同的硬件上，上一个会话和下一个会话中的行为也会稍有不同。在协程启动和结束间调用的 Update 回调数量是可变的，因此不要使协程依赖于某个对象的 Update 特定调用次数，应保持协程的简单性和独立性


  *ps：Unity的日志器非常昂贵，若使用的太频繁可能会导致一些不必要的性能峰值，最好只对代码库中最相关的部分进行针对性日志记录*

- **最小化正在进行的代码修改**

  为了查找性能问题而对应用程序进行代码更改需要小心，因为随着时间推移更改很容易被忘记，且会进行重新编译浪费时间。解决该问题的方法有：

  - 在做更改的地方用自己的名字添加一个标记或注释，以便以后容易的找到并删除它
  - 使用源代码控制工具，使代码库易于区分任何修改过的文件内容，并将它们恢复到原始状态，该方法能确保不必要的修改不会进入最终版本，若同时应用了一个修复程序，在提交更改前没有对所有修改过的文件进行复查，就不是一个有保证的解决方案。
  - 调试期间使用断点是首选方法，它可以跟踪完整的调用栈、变量数据、条件代码路径，没有任何更改代码的风险，也不会在重新编译上浪费时间，但该方法不总是可行

- **最小化内部影响**

  Unity编辑器仍存在一些问题使调试某些类型问题变的困难：

  - 若一帧需要很长时间去处理，Profiler 可能无法获取结果并记录在窗口中，如希望在程序或者场景初始化期间捕获数据就很麻烦，“自定义 CPU 分析” 将提供一些解决该问题的备选方案。


  - 若通过按键启动测试，且已经打开 Profiler，则在按键之前先回到 Game 窗口，因为Profiler是最近单击的窗口，编辑器就会将按键事件发送到该窗口，而不是运行的程序，没有游戏物体会捕捉到这次按键事件，这也会影响到 Game View 的渲染任务，甚至是使用 WaitForOfFrame yield 类型的协同程序。若 Game 窗口在编辑器中不可见但出于活动状态，则不会向该视图渲染任何内容，因此不会触发依赖 Game 窗口的渲染事件。
  - 垂直同步（VSync）用于将应用程序的帧率匹配将要显示到的设备的帧率，该特性减少了屏幕撕裂（后一副图像的一部分和前面重叠）。执行启用了 VSync 的 Profiler 可能会在 WaitForTargetFPS 标题下的 “CPU 使用情况” 区域产生许多嘈杂的峰值，因此在监视CPU峰值时禁用 VSync 复选框（在Edit->Project Settings->Quality 导航到当前选择的平台的子页面可以完全禁用 VSync 的功能）
  - 确保性能下降不是因为控制台窗口中出现大量异常和错误消息而导致的直接结果。Unity 的 Debug.Log 和类似的方法，在 CPU 使用率和堆内存消耗方面非常昂贵，导致发生垃圾回收甚至丢失 CPU 循环

- **最小化外部影响**

  应该检查有无有台进程消耗 CPU 周期或占用大量内存，可用内存不足通常会干扰测试，因为其会导致更多的缓存丢失，对虚拟内存页文件交换的硬盘访问，应用程序的响应速度通常较慢。

- **代码片段的针对性分析**

  在以上方法没有解决性能问题时，需要进一步分析实际问题。通过 Profiler 分析并确定什么地方出现问题，然后确定问题是否可以重现，在什么情况下出现性能瓶颈，问题代码块中的确切来源。完成这些需要对目标部分进行一些分析，对于 Unity 项目 基本上分为两类技术：

  - 从脚本代码控制 Profiler：通过 Profiler 类在脚本中控制，其中最重要的方法是在运行时激活和禁用分析功能的分隔符方法，通过 UnityEngine.Profiling.Profiler 类中的 BeginSample() 和 EndSample() 访问，它们仅在开发构建过程中编译，所以不会再未选中开发模式的版本构建过程中编译或执行，这种通常称为非操作或非操作代码。BeginSample 有带一个字符串参数的重载版本，允许样本的自定义名称出现在 “CPU 使用情况区域” 的 Hierarchy 模式中

  - 自定义 CPU 分析：在测试 CPU 使用情况时，真正需要的是一个准确的计时系统，一种快速、低成本的信息记录方法、一些用于测试它们的代码。Mono 框架在 System.Diagnostics 命名空间中提供了 Stopwatch 类，可以随时停止和启动 Stopwatch 对象，很容易度量自秒表启动以来经过了多长时间。但该类并不准确，只能精确到毫秒，最多精确到 1/10 毫秒。而使用 CPU 时钟计算高精度的实时时间是一项非常困难的任务。
  
    精度很重要，提高精度的一个有效方法是多次运行相同的测试，用总消耗时间除以测试运行的次数，就得到单次测试的准确时间，但若需要优化的的时间精度没那么高则不需要高精度。
  
    自定义脚本：
  
    ```c#
    public class CustomTimer : IDisposable
    {
        private string mTiemrName;
        private int mNumTests;
        private Stopwatch mWatch;
    
        public CustomTimer(string timerName, int numTests)
        {
            mTiemrName = timerName;
            mNumTests = numTests;
            if (mNumTests <= 0)
                mNumTests = 1;
            mWatch = Stopwatch.StartNew();
        }
    
        // using 块结束时自动调用
        public void Dispose()
        {
            mWatch.Stop();
            float ms = mWatch.ElapsedMilliseconds;
            UnityEngine.Debug.Log(string.Format("{0} finished:{1: 0.00} milliseconds total, {2: 0.000000} milliseconds per-test for {3} tests",
                mTiemrName, ms, ms / mNumTests, mNumTests));
        }
    }
    
    const int numTests = 1000;
    // using 块通常用于安全的确保非托管资源在超出作用域时被正确销毁，当该块结束时自动调用 Dispose() 方法来处理任何清理操作
    using(new CustomTimer("My Test", numTests)){
        for(int i = 0; i < numTests, i++){
            TestFunction();
        }
    }
    ```
  
    需要注意：
  
    1. 这只是对多个方法调用时间进行平均，若处理时间在不同的调用之间存在很大差异，则最终平均值不能很好的表现结果。
    2. 若内存访问是很常见的，则重复请求相同的内存块会导致人为提高缓存命中率，这会降低平均时间。
    3. 类似的人为原因，JIT 编译的效果被有效隐藏起来，只影响第一次调用。
    4. 若大量数据需要从磁盘上加载、初始化复杂的子系统、在执行其他操作前需要解析大量的 Awake() 和 Start() 回调，则 Unity 有很大的启动成本，此时执行测试代码会对结果产生重大影响。若想要准确测试则应在应用程序达到稳定状态之后才开始。

### 1.3 关于分析的思考

- 考虑性能优化的一种方式是剥离那些消耗宝贵资源的不必要任务，可以最小化浪费来最大化生产率

- 正确使用任何一种数据收集工具的建议，可以归纳为 3 种不同的战略：

  - 理解 Profiler 工具：Profiler 是一种设计良好、直观的工具，只需要花一两个小时通过一个测试项目研究其选项并阅读文档就可以了解它的大部分特性，对工具的有点、缺陷、特性和限制了解的越多就越能理解它提供的信息

  - 减少干扰：删除对当前情况来说不重要的数据，来减少需要处理的数据量。减少 Profiler 图形界面中的混乱将便于确定哪些子系统导致资源使用的峰值。GameObjects 可以停用以防止它们生成分析数据，有助于减少分析数据中的混乱。若逐渐停用对象，在停用特定对象时，性能突然变得更容易接受，俺么显然该对象与问题的根源有关。

  - 关注问题：不要因为无关紧要的人物和徒劳无益的追求而分心。

    Unity Profiler 进行分析的性能代价很小，使用 Deep Profiling 选项时代价更低，通过额外的日志记录可能将更小的性能成本引入应用程序中，但之后可能忘记何时引入代码。

    在数据采样期间实现的任何更改有时可能导致跟踪应用程序不存在的 bug，若在没有分析的情况下，瓶颈是可重现的、很明显的，就可以开始调查了，若在现有调查不断出现新的瓶颈，可能是测试代码引入的。

    当完成了分析并修复了，则在进行下一个调查前应确保对应用程序最后一次分析，以验证更改是否达到了预期效果。

    
