### 16.1 定义模板

**函数模板**

- 模板定义以template开始，后跟一个模板参数列表，是一个逗号分隔的一个或多个模板参数列表，用尖括号括起来。在模板定义中，模板参数列表不能空

- 在运行时，调用者提供实参初始化形参。模板参数表示在类或函数定义中用到的类型或值，在使用模板时，隐式或显式指定模板实参将其绑定到模板参数上

- 当调用一个函数模板时，编译器通常用函数实参来推断模板实参，其用推断出的模板参数实例化一个特定版本的函数，编译器生成的版本通常被称为模板的实例

- typename和class都可以作为关键字来指定模板参数类型，但typename更清楚地指出随后的名字是一个类型名，在定义模板时的作用是一模一样的。但在STL中还有种不常见的用法，即使用typename标识一个嵌套依赖类型名，比如T是一个模板参数，而T::name *无法在编译时确定是一个嵌套类型还是一个静态变量或函数的乘法，所以使用typename来标注这是一个类型名，但嵌套依赖类型作为继承列表或者初始化列表中的类型时不需要标注，因为肯定是一个类型

- 还可以在模板中定义非类型参数，它表示一个值而非类型，通过一个特定的类型名而非关键字class或typename来指定非类型参数。当一个模板被实例化时，非类型参数被一个用户提供的或编译器推断出的值所替代，这些值必须是常量表达式，从而允许编译器在编译时实例化模板，也可以将该值用到需要必须常量表达式的地方

  例：template<unsigned N\> voidsize(const char (&str)[N]){ }

  size("hi");			//实例化N为2

- 一个非类型参数可以是一个整型或是一个指向对象或函数类型的指针以及左值引用。绑定到非类型整型参数的实参必须是一个常量表达式，绑定到指针或引用非类型参数的实参必须具有静态的生存期，补鞥呢使用一个普通局部变量或动态对象作为指针或引用非类型模板参数的实参，指针参数也可以用nullptr或一个值为0的常量表达式来实例化

- 函数模板可以声明为inline或constexpr的，这两个说明符放在模板参数列表后，返回类型之前

- 模板程序应尽量减少对实参类型功能的要求

- 当编译器遇到一个模板定义时不会生成代码，当实例化出模板的一个特定版本时，才会生成代码

- 为了生成一个实例化版本，编译器需要掌握函数模板或类模板成员函数的定义，所以函数模板和类模板成员函数的定义通常放在头文件中

- 在编译模板时有三个阶段会报告错误：

  1. 编译模板本身时，可以检查语法错误
  2. 模板使用时，对于函数模板检查实参数目是否正确，参数类型是否匹配，对于类模板，可以检查用户是否提供了正确数目的模板实参
  3. 模板实例化时，此时才能真正发现类型相关的错误，依赖于编译器如何管理实例化，这类错误可能在链接时才能报告

- 编写模板时，代码不能是针对特定类型的，但通常对其所用类型的功能进行了假设，保证传递给模板的实参支持模板所要求的的操作以及操作在模板中能正确工作室调用者的责任

**类模板**

- 类模板用来生成类的蓝图，与函数模板不同之处是，编译器不能为类模板推断参数类型

- 一个类模板的每个实例都形成一个独立的类

- 为了阅读模板类代码，应该记住类模板的名字不是一个类型名，类模板用来实例化类型，而一个实例化的类型总是包含模板参数的

- 一个类模板中的代码如果使用了另一个模板，通常不将一个实际类型或值的名字用作其模板实参，通常将模板自己的参数当作被使用模板的实参

- 既可以在类模板内部，也可以在类模板外部为其定义成员函数，且定义在类模板内的成员被隐式声明为内联函数

- 类模板的成员函数本身是一个普通函数，但是类模板的每个实例都有其自己版本的成员函数，因而定义在类模板之外的成员函数必须以关键字template开始后接模板参数列表

- 默认情况下，一个类模板的成员函数只要当程序用到它是才进行实例化

- 在类模板自己的作用域中，可以直接时而用模板名而不提供实参

- 在类外模板哇已定义成员时，并不在类的作用域中，直到遇到类名才表示进入类的作用域，由于返回类型位于类作用域外，必须指出返回类型

- 如果一个类包含一个非模板友元，则友元吧诶授权可以访问所有模板实例，若友元自身是模板，则类可以授权给所有友元模板实例，也可以只授权给特定实例

  例：friend class A<C\>			//用C实例化的A类是C的友元

  template <typename T\> friend class B				//B的所有实例都是C的友元 

  friend class D;				//D是一个非模板类，它是所有C的实例的友元

- 在C++11中可以把模板参数声明为友元，这样实例化了哪个类型的模板，对应类型就是该类型的友元

- 可以定义一个typedef来引用实例化的类，但由于模板不是一个类型，不能定义一个typedef引用一个模板

- 类模板可以声明static成员，每个static数据成员必须有且只有一个定义，但对于类模板的每个实例都有一个独有的static对象

- 可以通过类类型对象来访问一个类模板的static成员，也可以使用作用域运算符直接访问成员，前提是必须引用一个特定的实例

- 类似于其他成员函数，类模板的一个static成员函数只有在使用时才会实例化

**模板参数作用域**

- 一个模板参数名的可用范围是在其声明之后，至模板声明或定义结束前
- 模板参数会隐藏外层作用域中声明的相同的名字，在模板内不能重用模板参数名。所以一个模板参数名在一个特定模板参数列表中只能出现一次
- 模板声明必须包含模板参数，声明中的模板参数名字不必与定义相同
- 一个给定模板的每个声明和定义必须有相同数量和种类（类型或非类型）的参数
- 一个特定文件所需要的所有模板的声明通常一起放置在文件开始的位置
- 默认情况下，C++语言假定通过作用域运算符访问的名字不是类型，如果希望使用一个模板类型参数的类型成员，必须显示告诉编译器该名字是一个类型，通过使用关键字typename来强调，不能换成class
- C++11中可以为函数和类模板提供默认实参，在更早的C++标准中只允许为类模板提供默认实参。在对应的模板参数后面加上=和默认类型名，且与函数相同，只有右侧有默认实参，它才可以具有默认实参
- 如果一个类模板为其所有模板参数都提供了默认实参，且希望使用这些默认实参，必须在使用时在模板名后跟一个空尖括号对（类似于想调用并使用拥有默认实参的函数）

**成员模板**

- 一个类无论是否为模板，可以包含本身是模板的成员函数，这种函数被称为成员模板，它不能是虚函数
- 在类模板外定义一个成员模板时，必须同时为类模板和成员模板提供模板参数列表，类模板的参数类表在前，后跟成员自己的模板参数列表
- 实例化一个类模板的成员模板，要同时提供类和函数模板的实参，函数模板的实参类型可以由编译器推断

**控制实例化**

- 相同的模板可能出现在多个对象文件中，当两个或多个编译的源文件使用了相同的模板，并提供了相同的模板参数时，每个文件中就都会有该模板的一个实例

- 在C++11中可以通过显式实例化来避免这种开销，一个显式实例化有如下形式：

  extern template declaration；					//实例化声明

  template declaration;									/./实例化定义

  当编译器遇到extern模板声明时，他不会在本文件中生成实例化代码，将一个实例化声明为extern就表示成咯在程序其他位置有该实例化的一个非extern声明或定义，对于一个给定的实例化版本，可能有多个extern声明，但必须只有一个定义

- 由于编译器在使用一个模板时自动对齐实例化，因此extern声明必须出现在任何使用此实例化版本之前

- 一个类模板的实例化定义会实例化该模板的所有成员，包括内联的成员函数，即使不使用某个成员也会被实例化。在一个类模板的实例化定义中，所用类型必须能用于模板的所有成员函数

**效率与灵活性**

- shared_ptr必须能直接访问其删除器，即删除器必须保存为一个指针或一个封装了指针的类
- 可以确定shared_ptr不是将删除器直接保存为一个成员，因为删除器的类型知道运行时才会知道。实际上在一个shared_ptr的生存期中，可以随时改变其删除器的类型。而类成员的类型在运行时是不能改变的，因此不能直接保存删除器
- 通过在编译时绑定删除器，unique_ptr避免了间接调用删除器的运行时开销，通过在运行时绑定删除器，shared_ptr使用户重载删除器更为方便

### 16.2 模板实参推断

- 编译器利用调用只用的函数实参来确定其模板参数称为模板实参推断

**类型转换与模板类型参数**

- 若一个函数形参的类型使用了模板类型参数，将采用特殊的初始化规则

- 类型转换能在调用中应用于函数模板的包括：

  - const转换：可以将一个非const对象的引用或指针传递给一个const引用或指针形参
  - 数组或函数指针转换：若函数形参不是引用类型，可以对数组或函数类型的实参应用正常的指针转换

  其他类型转换如算术转换、派生类想积累的转换以及用户自顶一个的转换都不能应用于函数模板

- 如果希望允许对函数实参进行正常的类型转换，可以将函数模板定义为两个类型参数

- 函数模板可以有用普通类型定义的参数，即，不涉及模板类型参数的类型，这种你函数实参不进行特殊处理：他们正常转换为对应实参的类型

**函数模板想显式实参**

- 在某些情况下，编译器无法推断出模板实参的类型，其他一些情况下，希望允许用户控制模板实例化，当函数返回类型与参数列表中任何类型都不相同时，这两种情况最常出现
- 当返回类型是一个模板参数，且与形参中的模板参数不同时，则无法推断返回类型，每次调用时都必须为其提供一个显式的模板形参
- 只有右边参数的显式模板实参才可以忽略，而且前提是它们可以从函数参数中推断出来，所以要将无法推断的放在模板参数列表的左边
- 对于模板类型参数已经显式指定了函数实参，也可以进行正常的类型转换

**尾置返回类型与类型转换**

- 在编译器遇到实参之前，实参是不存在的，为了使用实参来推断返回值的类型，需要使用尾置返回类型

- 获得元素类型可以使用标准库的类型转换模板，这些模板定义在头文件type_traits中，这个头文件中的类通常用于所谓的模板元程序设计

- remove_reference是一个类型转换模板，其中有一个模板类型参数和一个名为type的public类型成员，若用引用类型初始化remove_refernce，则type表示被引用的类型

- 标准类型转换模板：

  | 对Mod<T\>，Mod为     | 若T为                   | 则Mod<T\>::type为 |
  | -------------------- | ----------------------- | ----------------- |
  | remove_reference     | X&或X&&；否则           | X；T              |
  | add_const            | X&、const X或函数；否则 | T；const T        |
  | add_lvalue_reference | X&；X&&；否则           | T；X&；T&         |
  | add_rvalue_reference | X&或X&&；否则           | T；T&&            |
  | remove_pointer       | X*；否则                | X；T              |
  | add_pointer          | X&或X&&；否则           | X*；T*            |
  | make_signed          | unsigned X；否则        | X；T              |
  | make_unsigned        | 带符号类型X；否则       | unsigned X；T     |
  | remove_extent        | X[n]；否则              | X；T              |
  | remove_all_extenets  | X[n1\][n2\]...；否则    | X；T              |

  每个模板都有一个名为type的public成员，表示一个类型，此类型与模板自身的模板参数相关，其关系如模板名所示，若不可能或不必要转换模板参数，则type成员就是模板参数类型本身

**函数指针和实参推断**

- 当用一个函数模板初始化一个函数指针或为一个函数指针赋值时，编译器使用指针的类型来推断模板实参
- 当参数是一个函数模板实例的地址时，程序上下文必须满足对每个模板参数能唯一确定其类型或值

**模板实参推断和引用**

- 当一个函数是模板类型参数的一个左值引用时，正常绑定规则确定只能传递给它一个左值，实参可以是const类型，此时T将被推断为const类型的

- 若一个函数参数类型是const T&，正常绑定规则确定可以传递给它任何类型的实参，当函数参数本身是const时，T类型推断的结果不是const类型的

- 当一个函数参数是一个右值引用，正常绑定规则确定可以传递给它一个右值，类型推断T的类型是该右值实参的类型

- C++在正常绑定规则外定义了两个例外规则，这是move这种标准库设施正确工作的基础：

  1. 当一个左值给函数的右值引用参数，且此右值引用指向模板类型参数时，编译器推断模板类型参数为实参的左值引用类型。通常不能直接定义一个引用的引用，但铜鼓哦类型别名或通过模板参数间接定义时可以的
  2. 若间接创建一个引用的引用，则引用形成了“折叠”，除了一个例外，在其他情况下，引用会折叠成一个普通的左值引用类型，在C++11中，折叠规则扩展到右值引用，右值引用的右值引用会折叠成右值引用

  这两个规则导致两个重要结果：

  - 如果一个函数参数是一个指向模板类型参数的右值引用，则它可以被绑定到一个左值
  - 如果实参是一个左值，则推断出的模板实参类型将是一个左值引用，且函数参数将被实例化成一个普通左值引用参数

  这两个规则按时，可以将任意类型的实参传递给T&&类型的参数

- 模板参数可以推断为一个引用类型，这可能对模板内的代码产生影响

  例：T t =val;				//当T是引用类型时将是别名，值类型时将会拷贝，影响后续赋值

- 右值引用通常用于两种情况：模板转发其实参、模板重载

**理解std::move**

- move的原型：

  ```c++
  template <typename T>
  typename remove_reference<T>::type&& move(T&& t){
      return static_cast<typename remove_reference<T>::type&&>(t);
  }
  ```

- 通常情况下，static_cast只能用于其他合法的类型转换，但有对右值引用的特许规则：虽然不能隐式的将一个左值转换成右值引用，但可以用static_cast显式的将一个左值转换成一个右值引用

**转发**

- 某些函数需要将一个或多个实参雷同类型不变的转发给其他函数，在此情况下需要保持被转发实参的所有性质
- 若一个函数参数是指向模板类型参数的右值引用，它对应的实参的const属性和左值/右值属性也将得到保持，因为在引用类型中const是底层的
- 可以使用一个名为forward的新标准库设施来传递参数，它能保持原始实参的类型，定义在头原件utility中，forward必须通过显式模板实参来调用，forward返回该显式实参类型的右值引用，通过引用折叠可以保持给定参数的左右值属性

### 16.3 重载与模板

- 函数模板可以被另一个模板或一个普通非模板函数重载，名字相同的函数必须具有不同数量或类型的参数
  - 若涉及函数模板，则函数匹配规则会在以下几个方面受到影响：对于一个调用，其候选函数包括所有模板实参推断成功的函数模板实例
  - 候选的函数模板总是可行的，因为模板实参推断会排除任何不可行的模板
  - 可行函数按类型转换来排序，可以用于函数模板的调用的类型转换是非常有限的
  - 若恰有一个函数提供比任何其他函数更好的匹配，则选择刺函数，若有多个函数提供同样好的匹配，则：
    - 若同样好的函数中只有一个是非模板函数，则选择该函数
    - 若同样好的函数中没有非模板函数，而有多个函数模板，且其中一个模板比其他模板更特例化，则选择刺模板
    - 否则，调用有歧义

### 16.4 可变参数模板

- 一个可变参数模板就是一个接受可变数目参数的模板函数或模板类。
- 可变数目的参数被称为参数包，存在两种参数包：模板参数包，表示零个或多个模板参数；函数参数包，表示零个或多个函数参数。使用省略号来指出一个模板参数或一个函数参数表示包
- 在一个模板参数列表中，class...或typename...指出接下来的参数表示零个或多个类型的列表，一个类型名后跟一个省略号表示零个或多个给定类型的非类型参数列表。在函数参数列表中，若一个参数的类型是一个模板参数包，则此参数也是一个函数参数包
- 对于一个可变参数模板，编译器还会推断包中参数的数目
- 若需要知道包中有多少元素，可以使用sizeof...(可变参数名)，返回一个常量表达式，且不会对形参求值

**编写可变参数函数模板**

- 可以使用initializer_list来定义一个可接受可变数目实参的函数，但是所有实参必须具有相同类型或能转换成一个公共类型。而参数包可以接受不同类型
- 可变参数函数通常是递归的，第一步调用处理包中的第一个实参，然后用剩余实参调用自身

**包扩展**

- 对于一个参数包，除了获取大小之外，只能做的唯一的事情时扩展它，当扩展一个包时，还要提供用于每个扩展元素的模式，扩展一个包就是将它分解为构成的元素，对每个元素应用模式，获得扩展后的列表，通过在模式右边放一个省略号来触发扩展操作

  例如：

  ```
  template<typename T, typename... Args>
  ostream& print(ostream &os, const T &t, const Args&... rest)	//扩展Args
  {
  	os << t << "，";
  	return print(os, debug(rest)...);		//扩展rest，对每个rest包中元素都调用debug函数
  }
  ```

**转发参数包**

- 可以通过组合使用可变参数模板和forward机制来编写函数实现将其实参不变的传递给其他函数

### 16.5 模板特例化

- 一个特例化版本就是模板的一个独立的定义，在其中你一个或多个模板参数被指定为特定的类型
- 当特例化函数模板时，必须为原模板中的每个模板参数都提供实参，为了指出正在实例化模板，应使用关键字template后跟一个空尖括号对，指出将为原模板的所有模板参数提供实参
- 特例化的本质是实例化一个模板，而非重载它，因此特例化版本不影响函数匹配
- 模板及其特丽华版本应该声明在同一个头文件中，所有同名模板的声明应该放在前面，然后是这些模板的特例化声明
- 还可以特例化类模板，与函数模板不同的是，其不必为所有模板参数提供实参，可以只指定一部分而非所有模板参数，或是参数的一部分特性而非全部特性
- 部分特例化版本的名字与圆模板的名字相同，对于每个未完全确定类型的模板参数，在特例化版本的模板参数列表中都有一项预制对应。
- 可以只特例化特定成员函数而不是特例化整个模板，只需再专门定义一个函数的特例化版本（除了函数名前写类名，其他与实例化函数模板相同）