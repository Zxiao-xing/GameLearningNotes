

​		前几章已经建立了数学框架，我们需要看看渲染的第二种主要方法：将物体一个一个地绘制到屏幕上，或按物体顺序渲染。不像在光线追踪中，我们依次考虑每个像素并找到影响其颜色的物体，我们现在将依次考虑每个几何物体并找到它可能产生影响的像素。找到图像中所有被几何基元占用的像素的过程称为光栅化（rasterization），因此物体顺序渲染也可以称为光栅化渲染。从物体开始，以更新图像中的像素结束的操作序列称为图形管线（graphics pipeline）。  

*任何图形系统都有一个或多个可以直接处理的 “原始物体” 类型，更复杂的物体被转换成这些 “原始物体”。三角形是最常用的原始图形。*

*基于光栅化的系统也称为扫描线渲染器（scanline renderer）*

​		物体顺序渲染由于其效率而获得了巨大的成功。对于大型场景，数据访问模式的管理对性能至关重要，与重复搜索场景以获取着色每个像素所需的物体相比，在场景中访问每一个几何图形一次具有显著的优势。

​		本章的标题表明，只有一种方法可以进行物体顺序渲染。这当然不是真的——有两个目标迥异的图形管线的不同例子，一个是通过 OpenGL 和 Direct3D 等 API 支持交互渲染的硬件管线，另一个是用于电影制作的软件管线，支持 API 如 RenderMan 等。硬件管线必须运行得足够快，以便对游戏、可视化和用户界面做出实时反应。制作管线必须尽可能渲染最高质量的动画和视觉效果，并将规模扩大到巨大的场景，但这可能需要更多的时间。尽管这些不同的目标导致了不同的设计决策，但在大多数的（尽管不是全部）管线中，有相当一部分是共享的，本章试图关注这些共同的基础，而不是错误的关注和硬件管线联系更紧密的那些。

​		在物体顺序渲染中需要完成的工作可以组织到光栅化本身的任务中，光栅化之前是对几何体所做的操作，以及光栅化之后是对像素所做的操作。最常见的几何操作是应用矩阵变换，如前两章所讨论的，将定义几何的点从物体空间映射到屏幕空间，以便光栅化器的输入以像素坐标或屏幕空间表示。最常见的像素操作是移除隐藏表面（hidden surface removal），它让离观察器更近的表面出现在离观察器更远的表面前面。在每个阶段还可以包含许多其他操作，从而使用相同的通用流程实现各种不同的渲染效果。

​		出于本章的目的，我们将按照四个阶段来讨论图形管线（图 8.1）。几何物体从交互式应用程序或场景描述文件输入到管线中，它们总是用顶点集描述。在顶点处理阶段（vertex-processing stage）对顶点进行操作，然后使用这些顶点的基元被发送到光栅化阶段（resterization stage）。光栅化器将每个基元分解成若干片元（fragment），每个片元对应基元覆盖的每个像素。在片元处理阶段（fragment processing stage）对片元进行处理，然后在片元混合阶段（fragment blending stage）对每个像素对应的各个片元进行组合。

<img src="Image/08/08-图8.1.png" alt="08-图8.1" style="zoom:80%;" />

​																				**图8.1 图形管线的阶段**

### 8.1 光栅化（Rasterzaation）

​		光栅化是物体顺序图形的中心操作，而光栅器是任何图形管线的中心。对于每个传入的基元，光栅器有两个任务：它枚举（enumerate）基元覆盖的像素，并在基元中插值（interpolate）称为属性的值——这些属性的用途将在后面的示例中变清楚。光栅器的输出是一组片元，每个片元对应基元覆盖的每个像素。每个片元 “存在” 在一个特定的像素上，并携带自己的一组属性值。

​		在本章中，我们将介绍一个观点光栅化，以便使用它来渲染三维场景。同样的光栅化方法也用于在 2D 中绘制线条和形状——尽管在 “幕后” 使用 3D 图形系统来做所有的 2D 绘图已经变得越来越普遍。

#### 8.1.1 画线（Line Drawing）

​		大多数图形包都包含一个线绘制命令，它接受两个屏幕坐标中端点（参见图 3.10），并在它们之间绘制一条线。例如，调用端点 (1, 1) 和 (3, 2) 将打开像素 (1, 1) 和 (3, 2)，并在它们之间填充一个像素。对于一般的屏幕坐标端点 (x~0~, y~0~) 和 (x~1~, y~1~)，惯例应该绘制一些 “合理的” 像素集以近似它们之间的一条线。画这样的线基于线的方程，我们有两种类型的方程可供选择：隐式和参数。本节介绍使用隐式直线的方法。

*尽管我们经常使用整值端点作为示例，但正确支持任意端点也是很重要的。*

**用隐式直线方程画线**

​		用隐式方程画线最常见的方法是中点算法（midpoint algorithm）（Pitteway 1967, van Aken and Novak 1985）。中点算法最终画出了与 Bresenham 算法（Bresenham, 1965）相同的线，但它在某种程度上更直接。

​		首先要做的是找到这条直线的如 2.5.2 节隐式方程：
$$
f(x,y) \equiv{} (y_{0} - y_{1})x + (x_{1} - x_{0})y + x_{0}y_{1} - x_{1}y_{0} = 0
\tag{8.1}
$$
我们假设 x~0~ *≤* x~1~。如果它不成立，我们交换点使它成立。直线的斜率 m 是