- Lua 中的字符串既可以表示单个字符，也可以表示大量的字符，它是一串字节组成的序列。Lua 核心不关心这些字节以何种方式编码文本，它使用 8bit 存储字符，可以在字符串中存储任意的二进制数据，且可以使用任意一种 Unicode 编码，但优先考虑 UTF-8，因为 Lua 的字符串标准库默认处理 8bit 字符，但同样可以优雅的处理 UTF-8 字符，Lua5.3 还提供一个帮助使用 UTF-8 的函数库。
- Lua 中的字符串是不可变值，不能改变字符串但可以通过新建字符串来修改，可以使用长度操作符（#）获取字符串占用的字节数，可以使用连接操作符（..）进行字符串连接，其总是创建一个新的字符串。
- Lua 中的字符串也是自动内存管理对象之一，即 Lua 会负责字符串的分配和释放。

### 4.1 字符串常量

- 可以使用一对双引号或单引号来声明字符串常量，它们唯一的区别是：使用双引号时，字符串中的单引号不用转义，同理，使用单引号时，字符串中的双引号不用转义。

- Lua 支持的 C 语言风格的转义字符：\a（响铃）、\b（退格）、\f（换页）、\n（换行）、\r（回车）、\t（水平制表符）、\v（垂直制表符）、\\\（反斜杠）、\\"（双引号）、\\'（单引号）。

  Lua 还可以通过转义序列 \ddd（ddd 由最多 3 个十进制数字组成，若转义字符后面要跟其他数字，则 3 位要写完）和 \Xhh（hh 由必须两个十六进制数字组成）

  Lua5.3 还可以使用转义序列 \u{} 声明 UTF-8 字符，花括号中可以支持任意有效的十六进制。

### 4.2 长字符串/多行字符串

- 可以使用一对双方括号（[[]]）来声明长字符串或多行字符串常量，其中的转义序列不会被转义，若多行字符串的第一个字符是换行则会被忽略，后面的换行则都不会被忽略。

  若内容中包含（]]）导致字符串提前结束，则可以通过在第两边方括号加上等量的 = 字符（如[==[]==]）来解决，Lua 的语法扫描器会忽略等号数量不同的方括号。对注释而言该机制同样有效

- 对于非文本不应该滥用长字符串：虽然 Lua 字符串常量可以包含任意字节，但滥用该特性可能会导致一些问题。且像 "\r\n" 的 EOF 序列可能在读取时归一化为 "\n"，作为替代方案，最好就是把这些可能引起歧义的二进制数据用十进制或十六进制的数值转移序列进行表示，但这种转义形成的字符串往往很长。从 Lua5.2 开始引入了转义序列 \z，它会跳过后面所有的空白字符，直到遇到第一个非空白字符。

### 4.3 强制类型转换

- Lua 在运行时提供了数值与字符串之间的自动转换：

  在需要数值的情况时会尝试将字符串转换为数值，如算术操作，函数的参数等等。

  在需要字符串的情况会将数值转换为字符串（使用连接符号的使用使用空格将其分开，否则会把第一个点当作小数点）。Lua5.3 没有实现强制类型转换与整型的集成，它采用另一种简单而快速的方式：由于字符串不是整型值，所有任何有字符串参数的算术运算都被当作浮点运算处理。

  比较操作符不会进行类型转换，若在其中混用了字符串和数值则会抛出异常。

- 若需要显式的将字符串转换成数值可使用函数 tonumber，当字符串无法转换时返回 nil，否则按 Lua 语法扫描器规则返回整型或浮点型值。

  默认情况下该函数使用十进制，也可以通过添加第二个整数参数指明字符串中是使用 2 到 36 进制之间的任意进制，若字符串不满足进制要求返回 nil。

### 4.4 字符串标准库

- Lua 处理字符串的完整能力来自其字符串标准库，一些简单的函数如下：
  - string.len(s) 返回字符串 s 所占字节数，等价于 #s
  - string.rep(s, n) 返回将字符串 s 重复 n 次的结果
  - string.reverse(s) 返回字符串 s 翻转的结果
  - string.lower(s) 返回将字符串 s 中所有大写字母变为小写的结果
  - string.upper(s) 返回将字符串 s 中所有小写字母变为大写的结果
  - string.sub(s, i, j) 返回从字符串 s 中提取的第 i 个到第 j 个字符（包括第 i 和第 j），字符串第一个字符索引为 1，也支持负数索引，-1 代表最后一个字符
  - string.char() 接受零个或多个整数作为参数，将每个整数转换成对应的字符，返回由这些字符连接成的字符串
  - string.byte(s, i) 返回字符串 s 中第 i 个字符的内部数值表示，其第二个参数是可选的，若没有代表返回第一个字符。string.byte(s, i, j) 返回索引 i 到 j 之间的所有字符的数值表示。
  - string.format() 进行字符串格式化和将数值输出为字符串，返回第一个参数的副本，其中的每个指示符都被替换为使用对应格式进行格式化后的对应参数，指示符规则和 C 语言类似，由一个 % 和一个代表格式化的字母组成：d 代表一个十进制整数、x 代表一个十六进制整数，f 代表一个浮点数，s 代表字符串，% 和字母之间可以包含用于控制格式细节的其他选项，如通过 ”.数字“ 指定浮点数保留位数。这些指示符可以通过参阅 C 语言 printf 函数相关文档
  - string.find(s, c) 在字符串 s 中搜索模式匹配的 c，找到了则返回模式开始和结束的位置，否则返回 nil
  - string.gsub(s, c1, c2) 在字符串 s 中搜索模式匹配的 c1，并用 c2 进行替换，返回替换后的字符串和发生替换的次数
- Lua 限制了栈大小，所以也限制了一个函数返回值的最大个数，默认最大为 100 万个。

### 4.5 Unicode 编码

- Lua5.3 引入了用于操作 UTF-8 编码的 Unicode 字符串标准库，在引入该标准库之前 Lua 也提供对 UTF-8 字符串的合理支持。

  Lua 中的一些机制对 UTF-8 有效，字符串常量可以包含 UTF-8 数据，字符串连接也可以使用，字符串的比较会按照 Unicode编码中的字符代码顺序进行。

  字符串标准库中，函数 reverse、upper、lower、byte、char 不适用于 UTF-8 字符串，因为他们针对的是一字节字符。format（格式 %c 除外）、rep 适用于 UTF-8，len、sub 也可以用于 UTF-8，它们的索引以字节为单位不是以字符为单位

- utf8 标准库的一些函数，该标准库中大多数函数使用字节为索引：

  - utf8.len(s) 返回字符串 s 中 UTF-8 字符的个数（非字节），且会验证该字符串，若包含无效的字节序列则返回 false 和第一个无效字节的位置。
  - utf8.char() 接受零个或多个整数作为参数，将每个整数转换成对应的字符，返回由这些字符连接成的字符串
  - utf8.byte(s, i) 返回字符串 s 中第 i 个字符的内部数值表示，其第二个参数是可选的，若没有代表返回第一个字符。string.byte(s, i, j) 返回索引 i 到 j 之间的所有字符的数值表示。
  - utf8.offset(s, p) 返回字符串 s 中的第 p 个字符的字节位置，p 也可以为负数从字符串末尾开始计数
  - utf8.codes(s) 用于遍历字符串 s 的每一个字符

- 由于 Unicode 编码的字符和字素没有一对一的关系，且如字母之类的基本概念在不同语系中有差异，所以想要支持完整的 Unicode 就需要巨大的表，这和 Lua 需要的精简的大小不符，所以除了以上一些东西再没有任何机制支持，只能通过外部库来解决额外需求。

