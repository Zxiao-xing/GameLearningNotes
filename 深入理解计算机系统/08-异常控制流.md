- 假设从给处理器加电到断电为止，程序计数器值的序列为
  $$
  a_{0},a_{1},\cdots{},a_{n-1}
  $$
  每个 a~k~ 是某个指令 I~k~ 的地址。每次从 a~k~ 到 a~k+1~ 的过渡称为控制转移（control transfer），控制转移序列称为控制流（flow of control、control flow） 。最简单的一种控制流是一个 ”平滑“ 的序列，其中每个 I~k~ 和 I~k+1~ 在内存中都是相邻的。I~k~ 和 I~k+1~ 在内存中不相邻这种突变，通常是诸如跳转、调用、返回等一些熟悉的程序指令造成的，这些指令都是必要的机制，使程序能够对由程序变量表示的内部程序状态中的变化做出反应。

- 系统必须能够对系统状态的变化做出反应，这些系统状态不是被内部程序变量捕获的，也不一定要和程序执行有关。现代系统通过使控制流发生突变来对这些情况做出反应，一般把这些突变称为异常控制流（Exceptional Control Flow，ECF），其发生在计算机系统的各个层次，从硬件层到软件层

- 理解 ECF 的原因：

  - 帮助理解重要的系统概念。ECF是操作系统用来实现 I/O、进程、虚拟内存的基本机制。
  - 帮助理解应用程序是如何与操作系统交互的。应用程序使用一种叫做陷阱（trap）或系统调用（system call）的 ECF 形式，向操作系统请求服务，理解基本的系统调用机制将帮助理解这些服务是如何提供给应用的。
  - 帮助编写有趣的新应用程序。操作系统为应用程序提供了强大的ECF机制，用来创建新进程、等待进程终止、通知其他进程系统中的异常事件，以及检测和响应这些事件，理解之后就可以使用它们。
  - 帮助理解并发。ECF 是计算机系统中实现并发的基本机制。
  - 帮助理解软件异常如何工作。像 C++、Java 这样的语言通过 try、catch、throw 语句来提供异常机制。软件异常允许程序进行非本地跳转（违反通常的调用、返回栈规则的跳转）来相应错误情况，非本地跳转是一种应用层 ECF ，在 C 中是通过 setjmp 和 longjmp 函数提供的，理解这些低级函数帮助理解高级软件异常如何得以实现。

### 8.1 异常

- 异常（exception）是异常控制流（控制流的突变）的一种形式，它一部分由硬件实现一部分由操作系统实现，所以具体细节将随着系统的不同而有所不同，但对于每个系统基本的思想都是相同的，它用来响应处理器状态中的某些变化。
- 处理器中状态被编码为不同的位和信号。状态的变化称为事件（event），这些事件可能和当前指令的执行直接相关（虚拟内存缺页、算术溢出），也可能和当前指令的执行无关（系统定时器产生信号、I/O 请求完成）。
- 当处理器检测到有事件发生时就会通过一个叫异常表（exception table）的跳转表，进行一个间接过程调用到一个专门设计用来处理这类事件的操作系统子程序，称为异常处理程序（exception handler）。当异常处理程序完成处理后根据引起异常的事件类型，会发生以下其中一种情况：
  1. 处理程序将控制返回给事件发生时正在执行的指令
  2. 处理程序将控制返回给事件发生时的下一条指令
  3. 处理程序终止被中断的程序

#### 8.1.1 异常处理

- 系统中每种类型的异常都分配了一个唯一的非负整数的异常号（exception number），其中一些是由处理器的设计者分配的（被零除、缺页、内存访问违例、断点、算术溢出），其他是由操作系统内核的设计者分配的（系统调用、外部 I/O 设备的信号）。异常号是异常表中的索引，异常表的起始地址放在异常表基址寄存器（exception table base register）这个特殊 CPU寄存器

- 系统启动时，操作系统分配和初始化异常表，表目 k 包含异常 k 的处理程序的地址。

  运行时，当处理器检测到发生了一个事件并确定相应的异常号 k，随后处理器触发异常——执行间接过程调用，通过异常表的表目 k 转到相应的处理程序。剩下的工作由异常处理程序在软件中完成。

  处理程序处理完事件后，执行一条特殊的 “从中断返回” 指令可选的返回到被中断的程序，其将适当的状态弹回到处理器的控制和数据寄存器中，若异常中断的是用户程序，就将状态恢复到用户模式然后将控制返回给被中断的程序。

- 异常类似于过程调用，但有一些重要的不同之处：

  - 过程调用时，在跳转到处理程序之前处理器将返回地址压入栈中。

    异常调用时，会根据异常的类型，返回地址要么是当前指令，要么是下一条指令。

  - 异常调用中处理器也会把一些额外的处理器状态压到栈里，在处理程序返回时重新开始执行被中断的程序会需要这些状态。

  - 若控制从用户程序转移到内核，所有这些项目都会被压入内核栈中，而不是用户栈。

  - 异常处理程序需运行在内核模式下，它们对所有的系统资源都有完全的访问权限。

#### 8.1.2 异常的类别

| 类别              | 原因                | 异步/同步 | 返回行为             |
| ----------------- | ------------------- | --------- | -------------------- |
| 中断（interrupt） | 来自 I/O 设备的信号 | 异步      | 总是返回到下一条指令 |
| 陷阱（trap）      | 有意的异常          | 同步      | 总是返回到下一条指令 |
| 故障（fault）     | 潜在可恢复的错误    | 同步      | 可能返回到当前指令   |
| 终止（abort）     | 不可恢复的错误      | 同步      | 不会返回             |

<center>表8-4 异常的类别</center>

- 异步异常是由处理器外部的 I/O 设备中的事件产生的，同步异常是执行一条指令的直接产物。后三个异常类型是同步发生的，是执行当前故障指令（faulting instruction）的结果
- 各种异常类型的术语根据系统的不同而有所不同，处理器 ISA 规范通常会区分异步 “中断” 和同步 “异常”，但没有提供描述这些非常相似的概念的概括性术语，本文使用 “异常” 这个通用术语

**中断**

- 硬件中断不是由任何一条专门的指令造成的，硬件中断的异常处理程序常常称为中断处理程序（interrupt handler）

- I/O 设备通过向处理器芯片上的一个引脚发信号，并将异常号放到系统总线上来触发中断，该异常号表示了引起中断的设备。

  当前指令完成执行后，处理器注意到中断引脚的电压变高了，就从系统总线读取异常号然后调用适当的中断处理程序。

  当程处理程序返回时，将控制返回给下一跳指令，结果是程序继续执行就像没发生中断一样。

**陷阱和系统调用**

- 陷阱是有意的异常，是执行一条指令的结果。
- 陷阱最重要的用途是在用户程序和内核之间提供一个像过程一样的接口，该接口称为系统调用。
- 用户程序经常需要向内核请求服务（读文件、创建进程、加载程序、终止进程）。为了允许对这些内核服务受控的访问，处理器提供了一条特殊的 “syscall n” 指令请求服务 n。syscall 会导致一个到异常处理程序的陷阱，该处理程序解析参数并调用适当的内核程序。
- 从程序员角度看，系统调用和普通函数调用相同，但它们的实现非常不同：
  - 普通的函数运行在用户模式中，限制了函数可以执行的指令类型，且只能访问与调用函数相同的栈
  - 系统调用运行在内核模式中，允许系统调用执行特权指令并访问定义在内核中的栈

**故障**

- 故障是由错误情况引起，可能能被故障处理程序修正。

- 当故障发生时，处理器将控制转移给故障处理程序。

  若处理程序能够修正这个错误情况，就将控制返回给引起故障的指令，从而重新执行它。否则，返回到内核中的 abort 例程终止引起故障的应用程序。

**终止**

- 终止是不可恢复的致命错误造成的结果，通常是一些硬件错误。
- 终止处理程序不将控制返回给应用程序，而是返回给一个 abort 例程终止这个应用程序。

#### 8.1.3 Linux/x86-64 系统中的异常

- x86-64 系统中有 256 种不同的异常类型。0~31 对应 Intel 架构师定义的异常，所以对任何 x86-64 系统都一样。32~255 对应操作系统定义的中断和陷阱。

**Linux/x86-64 故障和终止**

| 异常号 | 描述         | 异常类别 |
| ------ | ------------ | -------- |
| 0      | 除法错误     | 故障     |
| 13     | 一般保护故障 | 故障     |
| 14     | 缺页         | 故障     |
| 18     | 机器检查     | 终止     |

<center>表8-9 x86-64系统中的异常实例</center>

- 除法错误：当应用试图除以零时或一个除法指令的结果对于目标操作数来说太大。Unix不会试图从该错误中恢复而是选择终止程序，Linux shell 通常报告为 “浮点异常（Floating exception）”。
- 一般保护故障：有许多原因可以导致该异常，但通常是因为一个程序引用了一个未定义的虚拟内存区域或因为程序试图写一个只读的文本段。Linux 不会尝试恢复这类故障，Linux shell 通常报告为 “段故障（Segmentation fault）”。
- 缺页：处理程序将适当的磁盘上虚拟内存的一个页面映射到物理内存的一个页面，然后重新执行产生该故障的指令。
- 机器检查：在导致故障的指令执行中检测到致命的硬件错误时发生的。机器检查处理程序从不返回控制给应用程序。

**Linux/x86-64 系统调用**

- Linux 提供几百种系统调用，当应用程序想要请求内核服务时可以使用。每个系统调用都有一个唯一的整数号，对应一个到内核中调转表（非异常表）的偏移量
- C 程序用 syscall 函数可以直接调用任何系统调用，但对于大多数系统调用标准 C 库提供了一组方便的包装函数，其将参数打包到一起以适当的系统调用指令陷入内核，然后将系统调用的返回状态传递回调用程序。本书中系统调用和其相关联的包装函数都被称为系统级函数
- x86-64 系统中，系统调用通过 syscall 的陷阱指令提供。所有到 Linux 系统调用的参数都是通过通用寄存器而不是栈传递的，按照惯例 %rax 包含系统调用号，%rdi、%rsi、%rdx、%r10、%r8、%r9 最多包含 6 个参数（第一个参数在第一个寄存器，以此类推）。从系统调用返回时，寄存器 %rcx 和 %r11 都会被破坏，%rax 包含返回值，-4095 到 -1 之间的负数返回值表明发生了错误，对应负的 errno。

### 8.2 进程

- 异常是允许操作系统内核提供进程（process）概念的基本构造块

- 进程的经典定义是：一个执行中程序的实例。系统中每个程序都运行在某个进程的上下文中，上下文是由程序正确运行所需的状态组成的，该状态包括存放在内存中的程序代码和数据、栈、通用寄存器的内容、程序计数器、环境变量、打开文件描述符集合。
- 进程提供给应用程序的关键抽象：
  - 一个独立的逻辑控制流，好像程序独占的使用处理器
  - 一个私有地址空间，好像程序独占的使用内存系统

#### 8.2.1 逻辑控制流

- 若调试器单步执行程序，可以看到一系列程序计数器（PC）的值，其唯一的对应于包含在程序的可执行目标文件中或在运行时动态链接到程序的共享对象中的指令，这个 PC 值的序列叫做逻辑控制流，或简称逻辑流
- 进程是轮流使用处理器的，每个进程执行它的流的一部分，然后被抢占（preempted）（暂时挂起），然后轮到其他进程执行。这对于一个运行在这些进程之一的上下文中的程序，看上去像在独占的使用处理器，但实际上会周期性的出现停顿。

#### 8.2.2 并发流

- 一个逻辑流的执行时间上与另一个流重叠，称为并发流（concurrent flow）这两个流被称为并发运行，该概念和处理器核数或计算机数无关

  多个流并发执行的一般现象称为并发（concurrency）

  一个进程和其他进程轮流运行称为多任务（multitasking）

  一个进程执行它控制流的一部分的每一个时间段叫做时间片（time slice），所以多任务也叫时间分片（time slicing）

  两个流并发的运行在不同的处理器核或计算机上，称为并行流（parallel flow），它们并行运行且并发执行，是并发流的一个真子集

#### 8.2.3 私有地址空间

- 在 n 位地址的机器上，地址空间是 2^n^ 个可能地址的集合（0 ~ 2^n^-1），进程为每个程序提供它自己的私有地址空间，私有是因为一般和这个空间中某个地址相关联的那个内存字节是不能被其他进程读或者写的。

  虽然该空间的内容一般是不同的，但其有相同的通用结构。Linux 中地址空间底部是保留给用户程序的，包括通常的代码、数据、堆、栈段，代码段总是从地址 0x400000 开始。地址空间顶部保留给内核，该部分包含内核在代表进程执行指令时使用的代码、数据、栈。

#### 8.2.4 用户模式和内核模式

- 为了是操作系统内核提供一个完美的程序抽象，处理器必须提供一种机制限制一个应用可以执行的指令和可以访问的地址空间范围，通常是用某个控制寄存器中的模式位（mode bit）来提供，其描述了进程当前享有的特权。

  当设置模式位进程就运行在内核模式（有时称超级用户模式），该进程可以执行指令集的任何指令，且访问系统中的任何内存位置。没有设置则运行在用户模式，该进程不允许执行特权指令，也不允许直接引用地址空间中内核区内的代码和数据，任何这样的尝试都会导致致命的保护故障，所以必须通过系统调用接口间接的访问内核代码和数据

- 运行应用程序代码的进程初始在用户模式中，通过中断、故障、系统调用这些异常可以变为内核模式。异常发生时控制传递到异常处理程序，处理器将模式变为内核模式，然后异常处理程序运行在内核模式中，当该程序返回应用程序时，处理器就把模式从内核模式改回用户模式。

- Linux 提供 /proc 文件系统，允许用户模式进程访问内核数据结构的内容，其将许多内核数据结构的内容输出为一个用户程序可以读的文本文件的层次结构。 2.6 版本的 Linux 内核引入 /sys 文件系统，输出关于系统总线和设备的额外的低层信息。

#### 8.2.5 上下文切换

- 操作系统内核使用上下文切换（context switch）这样的较高层形式的异常控制流来实现多任务，它的机制建立在那些较低层异常机制之上：

  1. 保存当前进程上下文
  2. 恢复某个先前被抢占的进程被保存的上下文
  3. 将控制传递给这个新恢复的进程

  当内核代表用户执行系统调用时可能会发生上下文切换：若系统调用因为等待某个事件发生阻塞，那么内核可以让当前进程休眠然后切换到另一个进程。即使系统调用没有阻塞，内核也可以决定执行上下文切换，不选择将控制返回给调用进程。

  中断也可能引发上下文切换，如周期性的定时器中断。

- 内核为每个进程维持一个上下文（context），其实内核重新启动一个被占用进程所需的状态，由一些对象的值组成，包括通用目的寄存器、浮点寄存器、程序计数器、用户栈、状态寄存器、内核栈、各种内核数据结构（描述地址空间的页表、包含当前进程信息的进程表、进程已代开文件的信息的文件表）

- 进程执行的某些时刻，内核可以决定抢占当前进程并重新开始一个先前被抢占的进程，该决策称为调度（scheduling），由内核中称为调度器（scheduler）的代码处理。

### 8.3 系统调用错误处理

- 当 Unix 系统级函数遇到错误时通常返回 -1，并设置全局整数变量 errno 表示什么出错了
- 程序员应总是检查错误，但直接写会使代码变的臃肿且难以读懂。可以编写错误处理包装函数，其调用基本函数，检查错误，若有任何问题就终止

### 8.4 进程控制

#### 8.4.1 获取进程 ID

- 每个进程都有一个唯一的非零正数进程 ID（PID）

```c++
// pid_t 为 Linux 系统 types.h 定义的 int

// 返回调用进程的 PID
pid_t getpid(void);

// 返回父进程的 PID
pid_t getppid(void);
```

#### 8.4.2 创建和终止进程

- 从程序员角度，可以认为进程总是处于下面三种状态之一：
  - 运行，要么在 CPU 上执行，要么在等待被执行且最终会被内核调度。
  - 停止，进程的执行被挂起（suspended），且不会被调度。当收到 SIGSTOP、SIGTSTP、SIGTTIN、SIGTTOT 信号时进程停止，直到收到 SIGCONT 信号，此时才会回到运行状态。
  - 终止，进程永远停止。会因为三种原因终止：
    1. 收到一个信号，该信号的默认行为是终止进程
    2. 从主程序返回
    3. 调用 exit 函数

```c++
// 以 status 退出状态终止进程
void exit(int status);

// 创建一个新的运行的子进程
// 子进程返回 0，父进程返回子进程 PID，出错返回 -1
pid_t fork(void);
```

- 新创建的子进程几乎和父进程相同：

  - 得到与父进程用户级虚拟空间相同但独立的一份副本，包括代码段、数据段、堆、共享库、用户栈
  - 得到与父进程任何打开文件描述符相同的副本，所以可以读写父进程中打开的任何文件
  - 它们最大的区别是有不同的 PID

- fork 函数调用一次，返回两次：

  - 父进程中，返回子进程的 PID
  - 子进程中，返回 0

  因为 PID 总是非零，所以返回值提供了一个明确的方法来分辨在父进程还是在子进程中执行

- 需要注意的地方：

  - 具有多个 fork 实例的程序可能会令人迷惑，需要仔细推敲
  - 父进程和子进程是并发运行的独立进程，内核能以任何方式交替执行它们的逻辑控制流中的指令

#### 8.4.3 回收子进程

- 当一个进程由于某种原因终止时，内核并不是立即将它从系统中清除，而是被保持在一种已终止的状态中直到它的父进程回收（reaped）。父进程回收时，内核将子进程的退出状态传递给父进程，然后抛弃已终止的进程，此时该进程就不存在了。
- init 进程的 PID 为 1，是所有进程的祖先。若一个父进程终止了，内核会安排 init 进程成为孤儿进程的养父去回收它们。
- 一个终止了但未被回收的进程成为僵死进程（zombie），长时间运行的程序总是应该回收它们的僵死子进程，因为它们仍然消耗系统的内存资源。

```c++
// 等待子进程终止或停止
// 成功返回子进程 PID，若 options 为 WNOHANG 返回 0，其他错误返回 -1
pid_t waitpid(pid_t pid, int *statusp, int options)
```

- waitpid 函数默认情况下（options = 0），挂起调用进程的执行，直到它的等待集合（wait set）中一个子进程终止，若刚调用就已经终止则立即返回，此时已终止的子进程已经被回收，内核会从系统中删掉它的所有痕迹

  判定等待集合的成员：通过参数 pid 来确定

  - pid > 0，等待集合是一个单独子进程，进程 ID 等于 pid
  - pid = -1，等待集合由所有子进程组成
  - 还支持包括 Unix 进程组的其他类型的等待集合

  修改默认行为：将 options 设置为以下常量的各种组合（通过或运算）来修改

  - WNOHANG：若等待集合中的任何子进程都还没有终止，立即返回 0。在等待子进程终止的同时还想进行其他工作可以使用该选项
  - WUNTRACED：挂起调用进程的执行，直到等待集合中的一个进程编程已终止或被停止，返回的 PID为导致返回的子进程 PID。而默认行为只返回已终止的子进程。想要检查已终止和被停止的子进程可以使用该选项
  - WCONTINUED：挂起调用进程的执行，直到等待集合中一个正在运行的进程终止或等待集合中一个被停止的进程收到 SIGCONT 信号重新运行

  检查已回收子进程的退出状态：若 statusp 参数非空，则 waitpid 就会在 status（statusp 指向的值） 放上导致返回的子进程状态信息。wait.h 头文件定义了解释 status 参数的几个宏：

  - WIFEXITED(status)：若子进程通过调用 exit 或返回正常终止，就返回真
  - WEXITSTATUS(status)：返回一个正常终止的子进程的退出状态。只有在 WIFEXITED 返回真才会定义该状态
  - WIFSIGNALED(status)：若子进程是因为一个未被捕获的信号终止，则返回真
  - WTERMSIG(status)：返回导致子进程终止的信号的编号，只有 WIFSIGNALED 返回真才定义该状态
  - WIFSTOPPED(status)：若引起返回的子进程当前是停止的，就返回真
  - WSTOPSIG(status)：返回引起子进程停止的信号的编号。只有 WIFSTOPPED 返回真才定义该状态
  - WIFSIGNALED(status)：若子进程收到 SIGCONT 信号重新启动，就返回真

  错误条件：

  - 若调用进程没有子进程则返回 -1，并设置 errno 为 ECHILD。
  - 若 waitpid 函数被一个信号中断，则返回 -1，并设置 errno 为 EINTR

```c++
// waitpid 函数的简单版本，等价于 waitpid(-1,&status,0)
// 成功返回子进程 PID，出错返回 -1
pid_t wait(int *statusp)
```

#### 8.4.4 让进程休眠

```c++
// 将进程挂起 secs 时间
// 若请求时间量已经到了则返回 0，若该函数因为信号中断而过早返回则返回剩余的休眠秒数
unsigned int sleep(unsigned int secs);

// 让调用函数休眠，直到该进程收到一个信号
// 总是返回 -1
int pause(void);
```

#### 8.4.5 加载并运行程序

```c++
// 在当前进程的上下文中加载并运行可执行目标文件 filename
// 若成功则不返回，错误返回 -1
// 参数列表 argv 指向以 null 结尾的指针数组，每个指针都指向一个参数字符串。按照惯例 argv[0] 是可执行目标文件名
// 环境变量列表 envp 指向以 null 结尾的指针数组，每个指针指向一个环境变量字符串，每个串都是形如 “name=value” 的键值对
int execve(const char *filename, const char *argv[], const char *envp[]);
```

- execve 加载了 filename 之后调用启动代码，启动代码设置栈并将控制传递给新程序的 main 函数

  ```c++
  // argc，给出 argv 数组中非空指针的数量
  // argv，指向 argv 数组中第一个条目
  // envp，指向 envp 数组中第一个条目
  int main(int argc, char *argv[], char *envp[]);
  ```

  Linux 提供几个函数来操作环境数组

  ```c++
  // 获取环境数组中键为 name 的键值对，若找到则返回指向 value 的指针，否则返回 NULL
  char *getenv(const char *name);
  
  // 若环境数组不存在键为 name 的键值对，则添加该键值对到数组中，若存在该键值对且 overwrite 不为 0 则会用 newvalue 替换以前的值
  // 成功返回 0，失败返回 -1
  int setenv(const char *name, const char *newvalue, int overwrite);
  
  // 若环境数组存在键为 name 的键值对，则删除它
  void unsetenv(const char *name);
  ```

### 8.5 信号

- Linux 信号，一种更高层的软件形式的异常，允许进程和内核中断其他进程。一个信号就是一条小消息，通知进程系统中发生了某种类型的一个事件，每种信号类型都对应于某种系统事件，因为底层的硬件异常是由内核异常处理程序处理的，正常情况下堆用户进程是不可见的，所以需要信号来通知用户进程。

| 序号 | 名称      | 默认行为                                       | 相应事件                       |
| ---- | --------- | ---------------------------------------------- | ------------------------------ |
| 1    | SIGHUP    | 终止                                           | 终端线挂断                     |
| 2    | SIGINT    | 终止                                           | 来自键盘的中断                 |
| 3    | SIGQUIT   | 终止                                           | 来自键盘的退出                 |
| 4    | SIGILL    | 终止                                           | 非法指令                       |
| 5    | SIGTRAP   | 终止并转储内存                                 | 跟踪陷阱                       |
| 6    | SIGABRT   | 终止并转储内存                                 | 来自 abort 函数的终止信号      |
| 7    | SIGBUS    | 终止                                           | 总线错误                       |
| 8    | SIGFPE    | 终止并转储内存                                 | 浮点异常                       |
| 9    | SIGKILL   | 终止（不能被捕获也不能忽略）                   | 杀死程序                       |
| 10   | SIGUSR1   | 终止                                           | 用户定义的信号1                |
| 11   | SIGSEGV   | 终止并转储内存                                 | 无效的内存引用（段故障）       |
| 12   | SIGUSR2   | 终止                                           | 用户定义的信号2                |
| 13   | SIGPIPE   | 终止                                           | 向一个没有读用户的管道做写操作 |
| 14   | SIGALRM   | 终止                                           | 来自 alarm 函数的定时器信号    |
| 15   | SIGTERM   | 终止                                           | 软件终止信号                   |
| 16   | SIGSTKFLT | 终止                                           | 协处理器上的栈故障             |
| 17   | SIGCHLD   | 忽略                                           | 一个子进程停止或终止           |
| 18   | SIGCONT   | 忽略                                           | 若该进程停止继续进程           |
| 19   | SIGSTOP   | 停止直到下一个 SIGCONT（不能被捕获也不能忽略） | 不是来自终端的停止信号         |
| 20   | SIGTSTP   | 停止直到下一个 SIGCONT                         | 来自终端的停止信号             |
| 21   | SIGTTIN   | 停止直到下一个 SIGCONT                         | 后台进程从终端读               |
| 22   | SIGTTOU   | 停止直到下一个 SIGCONT                         | 后台进程从终端写               |
| 23   | SIGURG    | 忽略                                           | 套接字上的紧急情况             |
| 24   | SIGXCPU   | 终止                                           | CPU 时间限制超出               |
| 25   | SIGXFSZ   | 终止                                           | 文件大小限制超出               |
| 26   | SIGVTALRM | 终止                                           | 虚拟定时器期满                 |
| 27   | SIGPROF   | 终止                                           | 剖析定时器期满                 |
| 28   | SIGWINCH  | 忽略                                           | 窗口大小变化                   |
| 29   | SIGIO     | 终止                                           | 在某个描述符上可执行 I/O 操作  |
| 30   | SIGGPWR   | 终止                                           | 电源故障                       |

<center>表2-26 Linux信号</center>

*多年前，主存是用一种称为磁芯存储器（core memory）的技术实现的，“转储内存”（dumping core）是一个历史术语，意思是把代码和数据内存段的映像写到磁盘上*

#### 8.5.1 信号术语

- 传送一个信号到目的进程是由两个不同步骤组成的：
  - 发送信号。内核通过更新目的进程上下文中的某个状态，发送一个信号给目的进程，一个进程可以发送信号给自己。可以有如下两种原因发送信号：
    1. 内核检测到一个系统事件
    2. 一个进程调用了 kill 函数，显示要求内核发送一个信号给目的进程
  - 接收信号。当目的程序被内核强迫以某种方式对信号的发送做出反应时，它就接收了信号，进程可以忽略该信号、终止、或通过执行一个叫信号处理程序（signal handler）的用户层函数捕获该信号
- 一个发出而没有被接收的信号称为待处理信号（pending signal），任何时刻一种类型至多有一个待处理信号，后续收到的该类型的信号会被直接丢弃。一个进程可以有选择性的阻塞接收某种信号，当一种信号被阻塞时仍可以被发送，但产生的待处理信号不会被接收，直到进程取消对这种信号的阻塞。

- 一个待处理信号最多只能被接收一次，内核为每个进程在 pending 位向量中维护着待处理信号的集合，而在 blocked 位向量中维护着阻塞的信号集合，只要传送了一个类型为 k 的信号内核就会设置 pending 中的第 k 位，只要接受了就会清除第 k 位。

#### 8.5.2 发送信号

- Unix 系统提供了大量向进程发送信号的机制，所有这些机制都是基于进程组（process group）概念

**进程组**

- 每个进程都只属于一个进程组，进程组是由一个正整数进程组 ID 标识的。默认情况下一个子进程和它的父进程属于同一个进程组

```c++
// 返回当前进程的进程组 ID
pid_t getpgrp(void);

// 改变自己或其他进程的进程组，pid 为 0 则使用当前进程的 PID，pgid 为 0 则使用 pid 指定的进程的 PID 作为进程组 ID。
// 成功返回 0，错误返回 -1
int setpgid(pid_t pid, pid_t pgid);
```

**用 /bin/kill 程序发送信号**

- /bin/kill 可以向另外的进程发送任意信号，负数 PID 会让信号发送到进程组 PID 中的每个进程。使用完整路径是因为某些 Unix shell 中有自己内置的 kill 命令

  ```c++
  // 发送 SIGKILL 信号给进程组 15213 中的每个进程
  /bin/kill -9 -15213
  ```

**从键盘发送信号**

- Unix shell 使用作业（job）这个抽象概念来表示对一条命令行求值而创建的进程，在任意时刻，至多有 1 个前台作业和 0~n 个后台作业。shell 为每个作业创建一个独立的进程组，进程组 ID 通常取自作业中父进程中的一个
- 输入 Ctrl+C 会让内核发送一个 SIGINT 信号到前台进程组中的每个进程，默认情况下是终止前台作业。输入 Ctrl+Z 会发送一个 SIGTSTP 信号到前台进程组中的每个进程，某人情况下是停止（挂起）前台作业

**用 kill 函数发送信号**

```c++
// 若 pid>0 则发送信号 sig 给进程 pid，若 pid=0 则发送信号 sig 给调用进程所在进程组中包括自己在内的每个进程，若 pid<0 则发送信号给进程组 |pid| 中的每个进程
int kill(pid_t pid, int sig);
```

**用 alarm 函数发送信号**

```c++
// 安排内核在 secs 秒后发送一个 SIGALRM 信号给调用进程，若 secs=0 则不会安排新的闹钟。且每次调用都会取消前面待处理的闹钟
// 若前面有待处理的闹钟则返回秒数，否则返回 0
unsigned int alarm(unsigned int secs);
```

#### 8.5.3 接收信号

- 当内核把进程 p 从内核模式切换到用户模式时，会检查 p 的未被阻塞的待处理信号集合（pending & !blocked），若该集合为空则内核将控制传递到 p 的逻辑控制流中的下一条指令，否则啮合选择集合中的某个信号 k（通常是最小的那个）并强制 p 接受信号 k，收到该信号会触发进程采取某种行为，当完成了之后控制返回 p 的逻辑控制流的下一条指令

- 每个信号类型都有一个预定义的默认行为，是下面之一：

  - 进程终止
  - 进程终止并转储内存
  - 进程停止直到被 SIGCONT 信号重启
  - 进程忽略该信号

  除了 SIGSTOP、SIGKILL 以外，其他的默认行为都可以修改

  ```c++
  typedef void (*sighandler_t)(int)
  // 改变和信号相关联的默认行为
  // 成功返回指向上一次处理程序的指针，出错返回 SIG_ERR(不会设置 errno)
  sighandler_t signal(int signum, sighandler_t handler)
  ```

  - 若 handler 为 SIG_IGN，则忽略类型为 signum 的信号

  - 若 handler 为 SIG_DFL，则类型为 signum 的信号行为恢复为默认行为

  - 若 handler 为用户定义的函数地址，称为信号处理程序，只要进程接收到类型为 signum 的信号就会调用该程序。将处理程序地址传递到 signal 函数从而改变默认行为称为设置信号处理程序（installing the handler），调用该程序称为捕获信号，执行该程序称为处理信号

    当一个进程捕获了类型 k 的信号，会调用其设置的处理程序，且会设置一个整数参数为 k，该参数允许同一个处理函数捕获不同类型的信号。当该程序执行完之后，控制通常传递回控制流中进程被信号接收中断位置处的指令（在某些系统中被中断的系统调用会立即返回一个错误）

#### 8.5.4 阻塞和解除阻塞信号

- Linux 提供阻塞信号的隐式和显式的机制：

  - 隐式阻塞机制，内核默认阻塞任何当前处理程序正在处理信号类型的待处理信号，即当执行某个信号的处理程序时再收到该信号，直到处理程序返回而只是待处理而没有接收

  - 显式阻塞机制，应用程序使用 sigprocmask 函数和它的辅助函数明确阻塞和解除阻塞选定的信号。

    ```c++
    // 改变当前阻塞的信号集合(blocked 位向量)，具体的行为依赖于 how 的值
    int sigprocmask(int how, const sigset_t *set, sigset_t *oldset);
    
    // 初始化 set 为空集合
    int sigemptyset(sigset_t *set);
    // 把每个信号都添加到 set 中
    int sigfillset(sigset_t *set);
    // 将 signum 添加到 set 中
    int sigaddset(sigset_t *set, int signum);
    // 将 signum 从 set 中删除
    int sigdelset(sigset_t *set, int signum);
    // 若 signum 是 set 的成员返回 1，否则返回 0
    int sigismember(const sigset_t *set, int signum);
    ```

    how：

    - SIG_BLOCK：把 set 中的信号添加到 blocked 中（blocked |= set）
    - SIG_UNBLOCK：从 blocked 中删除 set 中的信号（blocked &= !set）
    - SIG_SETMASK：blocked = set

    若 oldset 非空，那么 blocked 位向量变化之前的值保存值保存在 oldset 中

#### 8.5.5 编写信号处理函数

- 处理程序有几个属性使得它们很难推理分析：
  - 处理程序与主程序并发运行，共享同样的全局变量，因此可能与主程序和其他处理程序互相干扰
  - 如何以及何时接收信号的规则常常违反人的直觉
  - 不同的系统有不同的信号处理语义

**1.安全的信号处理**

- 一些保守的编写处理程序的原则：
  - 处理程序要尽可能简单
  - 在处理程序中只调用异步信号安全的函数，该函数能被星号处理程序安全的调用，有两个原因：要么是可重入的（如只访问局部变量），要么不能被信号处理程序中断
  - 保存和恢复errno。许多 Linux 异步信号安全的函数都会在出错返回时设置 errno，在处理程序中调用这样的函数可能会干扰主程序其他依赖于 errno 的部分，解决方法是在进入处理程序时将 errno 保存到局部变量中，然后在处理程序返回前恢复它，这个只有在处理程序会返回才有必要，若处理程序终止该进程就不需要了
  - 阻塞所有的信号，保护对共享全局数据结构的访问。从主程序访问一个数据结构通常需要一系列的指令，若指令序列被访问数据结构的处理程序中断，那么处理程序可能会发生该数据结构的状态不一致，得到不可预知的结果
  - 用 volatile 声明全局变量，强迫编译器引用该变量时都要从内存中读取，而不是有的时候从缓存读有的时候从内存读，保证全局数据的一致性
  - 用 sig_atomic_t 声明标志，保证对该标志的读和写是原子的。在常见的处理程序设计中，通常会用全局标志来记录收到的信号

**2.正确的信号处理**

- pending 位向量中每种类型的信号只对应一位，所以每种类型最多只有一个未处理的信号，重复到达的信号会直接丢弃，那么存在一个未处理信号表明至少有一个信号到达了，所以不能用信号来对其他进程中发生的事件计数。

**3.可移植的信号处理**

- 不同系统有不同的信号处理语义，如：

  - signal 函数的语义不同，有些老的 Unix 系统在信号被处理程序捕获后就把对该信号的反应恢复到默认值，有些系统上每次运行之后，处理程序必须调用 signal 函数重新显式的设置自己
  - 系统调用可被中断。如 read、write、accept 这样的系统调用会潜在的阻塞进程一段时间，称为慢速系统调用。在某些较早版本的 Unix 系统中，当处理程序捕获到一个信号时，被中断的慢速系统调用在信号处理程序返回时不再继续，而是立即返回给用户一个错误条件，并把 errno 设为 EINTR，这些系统上必须手动重启被中断的系统调用的代码

- Posix 定义了 sigaction 函数，允许用户在设置信号处理时，明确指定想要的信号处理语义，但其运用并不广泛，因为它需要设置一个复杂结构的条目。更简单的方式是定义一个包装函数 signal，其调用 sigaction。

  ```c++
  // 成功返回 0，出错返回 -1
  int sigaction(int signum, struct sigaction *act, struct sigaction *oldact)
      
  handler_t *Signal(int signum, handler_t *handler){
      struct sigaction action, oldaction;
      
      action.sa_handler = handler;
      sigemptyset(&action.sa_mask);	// 当前被处理的信号类型被阻塞
      action.sa_flags = SA_RESTART; 	// 若可能就自动重启被中断的系统调用
      
      // 调用 sigaction 函数
      if(sigaction(signum, &action, &old_action) < 0)
          unix_error("Signal error");
      
      return (old_action.sa_handler);	// 返回旧处理函数
  }
  ```

#### 8.5.6 同步流以避免讨厌的并发错误

- 一般而言，流可能交错的数量与指令的数量呈指数关系，这些交错情况中有一些会产生正确的结果，有些不行，所以要以某种方式同步并发流，从而得到最大的可行的交错的集合，每个可行的交错都能得到正确的结果

#### 8.5.7 显式等待信号

- 有时主程序需要显式的等待某个信号处理程序运行

  ```c++
  // 暂时用 mask 替换当前的阻塞集合，然后挂起该进程直到收到一个信号，该信号要么是运行一个处理程序，要么是终止该进程。若是前者则该函数从处理程序返回，并恢复到原来的阻塞集合；若是后者则不返回直接终止
  // 返回 -1
  int sigsuspend(const sigset_t *mask);
  ```

### 8.6 非本地跳转

- 非本地跳转（nonlocal jump），C 语言提供的一种用户级异常控制流形式，其将控制直接从一个函数转移到另一个当前正在执行的函数，而不需要经过正常的调用-返回序列。该功能由 setjmp 和 longjmp 函数提供，setjmp 调用一次返回两次，而 longjmp 从不返回

  ```c++
  // 在 env 缓冲区中保存当前调用环境，供 longjmp调用。调用环境包含程序计数器、栈指针、通用目的寄存器
  // 返回 0，该值不能赋值给变量
  int setjmp(jmp_buf env);
  int sigsetjmp(sigjmp_buf env, int savesigs);
  
  // 从 env 缓冲区中恢复调用环境，然后触发一个最近一次初始化 env 的 setjmp 调用的返回，然后 setjmp 返回并带有非零的返回值 retval
  void longjmp(jmp_buf, env, int retval);
  void siglongjmp(sigjmp_buf env, int retval);
  ```

  几个重要应用：

  - 允许从一个深层嵌套的函数调用中立即返回（而不用费力解开调用栈），通常由检测到某个错误情况引起的，且这个跳过允许跳过所有中间调用的特性可能产生意外后果（如分配内存跳过了结尾，但内存在结尾释放）
  - 使一个信号处理程序分支到一个特殊的代码位置，而不是返回到被信号到达中断了的指令位置

### 8.7 操作进程的工具

- Linux 系统提供的大量监控和操作进程的有用工具：
  - STRACE：打印一个正在运行的程序和它的子进程调用的每个系统调用的轨迹
  - PS：列出当前系统的进程（包括僵尸进程）
  - TOP：打印关于当前进程资源使用的信息
  - PMAP：显示进程的内存映射
  - /proc：一个虚拟文件系统，以 ASCII 文本格式输出大量内核数据结构的内容，用户程序可以读取这些内容