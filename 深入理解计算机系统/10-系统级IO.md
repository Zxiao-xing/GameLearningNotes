- 输入/输入（I/O）是在主存和外部设备（如磁盘驱动器、终端、网络）之间复制数据的过程。输入操作从 I/O 设备复制数据到主存，输出操作从主存复制数据到 I/O 设备。
- 所有语言的运行时系统都提供执行 I/O 的较高级别的工具，如 ANSI C 提供标准 I/O 库，包括 printf 和 scanf 带缓冲区的 I/O 函数，C++ 用它的重载操作符 << 和 >> 提供了类似的功能。Linux 系统中，通过使用由内核提供的系统级 Unix I/O 函数来实现较高级别的 I/O 函数。
- 学习 Unix I/O 的原因：
  - 帮助理解其他系统概念：I/O 是系统操作不可或缺的一部分，所以经常遇见 I/O 和其他系统概念之间的循环依赖。
  - 有时只能使用 Unix I/O：在某些重要情况下使用高级 I/O 函数不太可能或不太合适，如标准 I/O 库没有提供读取文件元数据的方式。且 I/O 库还存在某些问题，使用它进行网络编程非常冒险。

### 10.1 Unix I/O

- 一个 Linux 文件是一个字节的序列，所有的 I/O 设备都被模式化为文件，而所有的输入和输出操作都被当作相应文件的读和写来执行。这种方式允许 Linux 使用 Unix I/O 这样一个简单低级的应用接口，使所有的输入和输出都能用一种统一的方式执行：

  - 打开文件。一个应用程序通过要求内核打开相应的文件，来宣告它想要访问一个 I/O 设备。内核返回一个称为描述符的小的非负整数，用来在后续操作中标识这个文件。内核记录有关打开文件的所有信息，应用程序只需记住这个描述符。

  - Linux shell 创建的每个进程开始时都有三个打开的文件：标准输入（描述符为 0）、标准输出（描述符为 1）、标准错误（描述符为 2）。<unistd.h> 定义了常量 STDIN_FILENO、STDOUT_FILENO、STDERR_FILENO，可以代替显式的描述符值。

  - 改变当前的文件位置。对于每个打开的文件，内核保持一个文件位置 k，初始为0。该文件位置是从文件开头起始的字节偏移量，应用程序能通过执行 seek 操作显式的设置文件的当前位置。

  - 读写文件。一个读操作就是从文件复制 n 个字节到内存，从当前未见位置 k 开始，然后 k 增加到 k+n。对于一个 m 字节的文件，当 k >= m 时执行读操作会触发一个 end-of-file（EOF）条件，应用程序能检测到这个条件。

    写操作是从内存复制 n>0 个字节到一个文件，从当前文件位置 k 开始，然后更新 k。

  - 关闭文件。当应用完成对文件的访问后通知内核关闭该文件。内核释放文件打开时创建的数据结构，并将该文件描述符恢复到可用的描述符池中。无论一个进程因为什么元婴终止，内核都会关闭所有打开的文件并释放它们的内存资源。

### 10.2 文件

- 每个 Linux 文件都有一个类型来表明它在系统中的角色：
  - 普通文件（regular file）：包含任意数据，对应用程序分为文本文件（text file）（只含有 ASCII 和 Unicode 字符）和二进制文件（binary file）（所有其他文件）。对内核来说它们没有区别。Linux 文本文件包含了一个文本行序列，每一行都是一个字符序列，以新行符（“\n”）结束，它与 ASCII 的换行符（LF）是一样的，为 0x0a。
  - 目录（directory）：包含一组链接（link）的文件，每个链接都将一个文件名映射到一个文件，该文件可能是另一个目录。每个目录至少含有两个条目：“.” 到该目录自身的连接，".." 到目录层次结构中父目录（parent directory）的链接。
  - 套接字：用来和另一个进程进行跨网络通信的文件
  - 命名通道（named pipe）
  - 符号链接（symbolic link）
  - 字符和块设备（character and block device）
- Linux 将所有文件都组织成一个目录层次结构（directory hierarchy），以 / 的根目录确定，每个文件都是根目录的直接或间接后代。每个进程都有一个当前工作目录（current working directory）来确定其在目录层次结构中的当前位置。该位置用路径名（pathname）来指定，它是一个字符串，包含一个可选斜杠，后跟一系列文件名，文件名间用斜杠分割，其有两种形式：
  - 绝对路径名（absolute pathname）：以一个斜杠开始，表示从根节点开始的路径
  - 相对路径名（relative pathname）：以文件名开始，表示从当前工作目录开始的路径

### 10.3 打开和关闭文件

```c++
// 打开一个已存在文件或创建一个新文件
// 成功则为新文件描述符，出错为 -1
int open(char *filename, int flags, mode_t mode);
```

- 该函数将 filename 转换为一个文件描述符并返回，返回的总是在进程中当前没有打开的最小描述符。

  flags 参数指明进程打算如何访问这个文件，或为一个至多位掩码的或运算，为写提供额外指示：

  - O_RDONLY：只读
  - O_WRONLY：只写
  - O_RDWR：读写
  - O_CREAT：若文件不存在就创建它的一个截断的空文件。
  - O_TRUNC：若文件已存在就截断它。
  - O_APPEND：每次写操作前将文件位置放在文件结尾处。

  mode 参数指定了新文件的访问权限位。每个进程都有一个 umask（通过调用 umask 函数设置），当进程通过带有 mode 参数的open函数创建新文件，文件的访问权限位被设置为 mode & ~umask。

  | 掩码    | 描述                         |
  | ------- | ---------------------------- |
  | S_IRUSR | 拥有者能读该文件             |
  | S_IWUSR | 拥有者能写该文件             |
  | S_IXUSR | 拥有者能执行该文件           |
  | S_IRGRP | 拥有者所在组成员能读该文件   |
  | S_IWGRP | 拥有者所在组成员能写该文件   |
  | S_IXGRP | 拥有者所在组成员能执行该文件 |
  | S_IROTH | 任何人能读该文件             |
  | S_IWOTH | 任何人能写该文件             |
  | S_IXOTH | 任何人能执行该文件           |

```c++
// 关闭一个打开的文件
// 成功返回 0，出错返回 -1。关闭一个已关闭描述符会出错
int close(int fd)
```

### 10.4 读和写文件

```c++
// 从描述符 fd 的当前文件位置复制最多 n 个字节到内存位置 buf
// 成功返回读的字节数，EOF 返回 0，出错返回 -1
ssize_t read(int fd, void *buf, size_t n);

// 从内存位置 buf 复制最多 n 个字节到描述符 fd 的当前文件位置
// 成功返回写的字节数，出错返回 -1
ssize_t write(int fd, const void *buf, size_t n);
```

- 在某些情况下，read 和 write 传送的字节比应用程序要求的少，这些不足值（short count）不表示有错误。原因有：
  - 读时遇到 EOF。除了该情况，读和写任何磁盘文件都不会遇到不足值。
  - 从终端读文本行。若打开文件是与终端相关联的，那么每个 read 函数一次传送一个文本行，返回的不足值等于文本行大小。
  - 读和写网络套接字。若打开的文件对应于网络套接字，那么内部缓冲约束和较长的网络延迟会引起 read 和 write 返回不足值。若想创建健壮的网络应用，必须通过反复调用 read 和 write 处理不足值，知道所需要的字节全部传送完毕
  - 对 Linux 管道调用 read 和 write 也可能出现不足值。
- 在 x86-64 系统中，ssize_t 定义为 long，size_t 被定义为 unsigned long。

### 10.5 用 RIO 包健壮的读写

- RIO（Robust I/O）自动处理不足值。其提供两类不同的函数：
  - 无缓冲的输入输出函数。这些函数直接在内存和文件之间传送数据，没有应用级缓冲。这对将二进制数据读写到网络和从网络读写二进制数据时很有用。
  - 带缓冲的输入函数。允许高效的从文件中读取文本行和二进制数据，这些内容缓存在应用级缓冲区中。带缓冲的 RIO 输入函数是线程安全的，在同一描述符上可以被交错的使用。

#### 10.5.1 RIO 的无缓冲的输入输出函数

```c++
// 从描述符 fd 的当前文件位置传送最多 n 字节到内存位置 usrbuf
// 成功返回传送的字节数，EOF 返回 0，出错返回 -1
ssize_t rio_readn(int fd, void *usrbuf, size_t n);

// 从位置 usrbuf 传送 n 个字节到描述符 fd
// 成功返回传送的字节数，出错返回 -1
ssize_t rio_writen(int fd, void *usrbuf, size_t n);
```

- 若 rio_readn 和 rio_writen 被一个从应用信号处理程序的返回中断，则每个函数都会手动的重启 read 或 write。

### 10.6 读取文件元数据

```c++
// 检索文件的信息(文件的元数据(metadata))，填写进 stat 结构体。前者以文件名，后者以描述符
// 成功返回 0，出错返回 -1
int stat(const char *filename, struct stat *buf);
int fstat(int fd, struct stat *buf);
```

### 10.7 读取目录内容

```
// 成功返回指向目录流的指针，否则返回 NULL
DIR *opendir(const char *name);
```

- 其中 name 是路径名。流是对条目有序列表的抽象，这里指目录项的列表。

```
// 成功返回指向下一个目录项的指针，若没有更多的目录项或出错返回 NULL
struct dirent *readdir(DIR *dirp);
```

- 出错返回 NULL 并设置 errno，但唯一能区分错误和流结束情况是检查调用 readdir 后 errno 是否被修改过。

- 每个目录项都是一下结构：

  ```c++
  struct dirent{
  	ino_t d_ino;		// 文件名
  	char d_name[256];	// 文件位置
  };
  ```

  虽然有些 Linux 版本包含了其他的结构成员，但这两个对所有系统都是标准的。

```c++
// 关闭流并释放其所有的资源
// 成功返回 0，错误返回 -1
int closedir(DIR *dirp);
```

### 10.8 共享文件

- 可以用许多不同的方式来共享 Linux 文件，内核用三个相关的数据结构来表示打开的文件：
  - 描述符表（scriptor table）。每个进程都有它独立的描述符表，表项是由进程打开的文件描述符来索引，每个打开的描述符表项指向文件表中的一个表项。
  - 文件表（file table）。打开文件的集合是由一张文件表来表示的，所有进程共享这个表，每个文件表的表项组成包括当前的文件位置、引用计数（指向该表项的描述符表项数）、一个指向 v-node 表中对应表项的指针等等。关闭一个描述符会减少相应的文件表项中的引用计数，内核直到引用计数为 0 时才删除该表项。
  - v-node 表（v-node table）。同文件表一样，所有进程共享这张 v-node 表，每个表项包含 stat 结构中的大多数信息，包括 st_mode 和 st_size 成员。
- 一种典型情况是，每个描述符对应一个不同的文件。还有种情况是多个描述符通过不同的文件表表项来引用同一个文件，关键思想史每个描述符都有它自己的文件位置，对不同的描述符的读操作可以从文件的不同位置获取数据。

### 10.9 I/O 重定向

- Linux shell 提供了 I/O 重定向操作符，允许用户将磁盘文件和标准输入输出联系起来

```c++
// 复制描述符表表项 oldfd 到 newfd，覆盖 newfd 以前的内容，若它已经打开了，则会在复制 oldfd 之前关闭 newfd
// 成功返回非负的描述符，出错则返回 -1。
int dup2(int oldfd, int newfd);
```

### 10.10 标准 I/O

- C 语言定义了一组高级输入输出函数，称为标准 I/O 库，为程序员提供了 Unix I/O 的较高级别的替代，该库提供了打开和关闭文件的函数（fopen 和 fclose）、读和写字节的函数（fread 和 write）、读和写字符串的函数（fgets 和 fputs）、复杂的格式化 I/O 函数（scanf 和 printf）。标准 I/O 库将一个打开的文件模型化为一个流，对程序员而言一个流就是一个 FILE 类型的结构的指针，每个 ANSI C 程序开始时都有三个打开的流 stdin、stdout、stderr，分别对应标准输入、标准输出、标准错误。
- 类型为 FILE 的流是对文件描述符和流缓冲区的抽象，流缓冲区的目的是使开销较高的 Linux I/O  系统调用的数量尽可能的小。

### 10.11 综合：我该使用哪些 I/O 函数？

- Unix I/O 模型是在操作系统内核中实现的，应用程序可以通过诸如open、close、lseek、read、write、stat 这样的函数访问 Unix I/O，较高级别的 RIO 和标准 I/O 函数都是基于 Unix I/O 函数来实现的。

- 选择 I/O 函数的一些基本指导规则：

  - 只要有可能就使用标准 I/O。对磁盘和终端设备 I/O 来说，标准 I/O 是首选方法。

  - 不要使用 scanf 来读二进制文件，这样的函数是专门设计来读取文本文件的。

  - 对网络套接字的 I/O 使用 RIO 函数。Linux 对网络的抽象是一种称为套接字的文件类型，它的文件描述符称为套接字描述符，应用程序通过读写套接字描述符来与运行在其他计算机上的进程实现通信。

    标准 I/O 流从某种意义上来说是全双工的，因为程序能够在同一个流上执行输入和输出，但对流的限制和对套接字的限制有时会互相冲突：

    - 限制 1：若中间没有插入对 fflush、fssek、fsetpos、rewind 的调用，一个输入函数不能跟在一个输出函数之后，fflush 函数清空与流相关的缓冲区，后三个函数使用 Unix I/O lseek 函数来重置当前文件位置。
    - 限制 2：若中间没有插入对 fseek、fsetpos、rewind 的调用，则一个输出函数不能跟在一个输入函数之后，除非该输入函数遇到了一个文件结束。

    这些限制给网络应用带来了一个问题，因为对套接字使用 lseek 函数是非法的。第一个限制可以通过采用每个输入操作前刷新缓冲区的规则来满足，第二个限制的唯一方法是对同一个打开的套接字描述符打开两个流，一个用来读一个用来写。，但该方法要求应用程序在两个流上都要调用 fclose 这样才能释放与每个流相关联的内存资源避免内存泄漏，但每一个都试图关闭同一个底层的套接字描述符，所以第二个 close 操作会失败，对顺序的程序这不是问题，对线程化的程序就会导致灾难。

    