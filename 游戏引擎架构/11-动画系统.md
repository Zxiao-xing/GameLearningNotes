### 11.1 角色动画的类型

#### 11.1.1 赛璐璐动画

- 所有游戏动画技术的前身都是传统动画或手绘动画，该技术用于早期的卡通动画，这种动画的动感由连续快速显示一系列静止图片所产生，这些图片称为帧。可将实时三维渲染想象为传统动画的电子形式，把一系列静止的全屏影像不断的向观众展示，产生动感
- 赛璐璐动画（cel animation）是传统动画的一种。赛璐璐是透明的塑料片，可以在上面绘画。把一连串含动画的赛璐璐放置于固定的手绘背景之上就成产生动感，而无须不断重复绘制静态的背景。
- 精灵动画（sprite animation）赛璐璐动画的电子版本。精灵是一张小位图，叠在全屏的背景影像之上而不会扰乱背景，通常由专门的图形硬件绘制，其是二维游戏时代最主要的技术

#### 11.1.2 刚性层阶式动画

- 刚性层层阶式动画：最初实现三维角色动画的方法。角色由一堆刚性部分建造而成，人形角色通常会分拆为骨分、躯干、上臂、下臂、大腿、小腿、手部、脚部及头部，这些刚性部分以层阶形式彼此约束（类似于骨骼），这样能使角色自然的移动
- 问题：角色的身体会在关节位置产生碍眼的“裂缝”，对于确实由刚性不见组成的机器人及机械，刚性层阶式动画能配合的很好

#### 11.1.3 每顶点动画及变形目标

- 每顶点动画（per-vertex animation）：动画师为网格的顶点添加动画，这些动作数据导入游戏引擎后就能告诉引擎在运行时如何移动顶点啊，该技术能产生任何网格变形（仅仅收到镶嵌的限制）

  缺点：这是一个数据密集的技术，因为每个顶点随时间改变的动作信息都需要存储下来，实时游戏中很少使用该技术

- 变形目标动画（morph target animation）：每顶点动画的变种。由动画师移动网格的顶点，但仅制作相对少量的固定极端姿势，在运行时把两个或以上的姿势混合就能生成动画，每个顶点的位置是简单的把每个极端姿势的位置进行线性插值而得。

  常用于面部动画，因为人脸具有非常复杂的解剖结构，其动作由大约50组肌肉所驱动，动画师能使用变形目标动画去完全控制脸上的每个顶点，制作出细微及极端的移动模拟面部肌肉组织

- 有些工作室使用具有数百个关节的面部索具取代变形目标，有些合并两种技术，使用关节索具完成基本姿势，再使用变形目标做细节调整

#### 11.1.4 蒙皮动画

- 蒙皮动画（skinned animation）：骨骼由刚性的骨头构建而成，但这刚性部件并不会渲染显示。称为皮肤的的光滑三角形网格会绑定于骨骼上，其顶点会跟随关节移动。蒙皮上的每个顶点可按权重绑定至多个关节，因此当关节移动时蒙皮可以自然的拉伸

  优点：有每顶点动画及变形目标动画一样允许组成网格的三角形做出变形，也有刚性层阶式东安湖的高效性能及内存使用量特性，能产生相当接近真实皮肤和衣着的移动

#### 11.1.5 把动画方法视为数据压缩技术

- 可以将最富有弹性的动画系统想象成动画师能控制物体表面上无穷多个点，但用该方法制作动画结果是包含无穷多的数据。

  理想的简化版本是控制三角形网格的顶点，实际上是把描述动画的信息加以压缩限制只能移动顶点。

  变形目标可以被理解为进一步的压缩，加入更多的约束，顶点只能在一组固定数目的预定义顶点位置间的线性路径中移动

  骨骼动画通过让大量顶点只能跟随较少量的骨骼关节移动

- 在权衡动画技术时可以用压缩的方法来考虑，选择动画技术的目标是能提供最佳压缩而又不会产生不能接受的视觉瑕疵，骨骼动画能提供最佳的压缩，因为每个关节的移动会扩大至多个顶点的移动，角色的四肢大部分行为像刚体，能有效的使用骨骼移动。面部动作往往更为复杂，每个顶点的移动更加独立，若使用骨骼制作没有视觉下次的动画，所需的关节就接近顶顶啊数量，降低了骨骼动画作为压缩的效能，另一个使用变形动画的原因是更符合实际

### 11.2 骨骼

- 骨骼由刚性的关节层阶结构所过程。“关节”和“骨头”两个属于通常会交替使用，但从技术上说”关节“是动画师直接控制的物体，”骨头“是指连接关节的东西

#### 11.2.1 骨骼层次结构

- 骨骼的关节形成属性结构，其中一个关节为根节点，其他是子孙。蒙皮动画所用的关节层阶结构通常和刚性层阶相同。通常为每个关节赋予0-N-1的索引，每个关节只有一个父节点所以只需要存储父节点的索引即可，根节点父索引存储为-1

#### 11.2.2 在内存中表示骨骼

- 骨骼通常由一个细小的顶层数据表示，该结构含有关节数组，关节的存储次序通常会保证每个子关节都位于其父关节之后，数组中首个关节总是骨骼的根关节

- 在动画数据结构中，通常会使用关节索引引用关节，在蒙皮三角形网格中，每个顶点使用索引引用其绑定关节，使用索引引用关节无论是从存储空间上（通常是8位整数）还是查找引用关节时间中，都比使用关节名字高效

- 每个关节的数据结构通常包含：

  - 关节名字，可以是字符串或32位字符串散列标识符
  - 骨骼中父节点的索引
  - 关节的绑定姿势的逆变换。绑定姿势指蒙皮网格顶点被绑定至骨骼时，关节的位置、定向及缩放

  ```c++
  struct Joint{
  	Matrix4x3 m_invBindPose;	// 绑定姿势逆变换
  	const char* m_name;			// 关节名字
  	uint8_t m_iParent;			// 父关节
  }
  
  struct Skeleton{
  	uint32_t m_jointCount;		// 关节总数
  	Joint* m_aJoint;			// 关节数组
  }
  ```

### 11.3 姿势

- 一个关节的姿势被定义为关节相对某参考系的位置、定向和缩放，通常以4x4、4x3矩阵或SQT（scale、quaternion、translation），骨骼的姿势仅仅是其所有关节姿势的集合，并通常简单的以SQT数组表示

#### 11.3.1 绑定姿势

- 绑定姿势：有时又称参考姿势或放松姿势，是三维网格绑定至骨骼之前的姿势，即把网格当作正常、没有蒙皮、完全不涉及骨骼的三角形网格来渲染的姿势。有时也叫T姿势，因为角色通常会站着双腿稍分开并把双臂向左右伸直形成T字形，特别选择此姿势是因为该姿势中的四肢远离身体较容易把顶点绑定至关节

#### 11.3.2 局部姿势

- 局部姿势：描述相对父节点的姿势，最常见的关节姿势是相对于父节点来指定的，能令关节自然的移动，对父节点进行的变换对子节点也有相同的影响。几乎都存储为SQT格式
- 每个关节都定义了一个局部的坐标空间
- 数学上是关节姿势就是一个4x4仿射变换矩阵，拥有平移缩放和旋转。整个骨骼的姿势就是所有关节姿势的集合
- 有些游戏引擎不允许关节缩放，就会忽略缩放将其假定为单位矩阵，有些引擎会限定缩放为统一缩放可以用单个标量表示。有些引擎也支持非统一缩放。但游戏引擎几乎不允许切变所以不会以3x3的缩放/切变矩阵表示。限制引擎为统一缩放确保包围球不会变换成椭球体，能大幅度简化按每关节计算的平截头体剔除以及碰撞测试

- 内存中表示关节姿势

  ```c++
  // SQT变换
  struct JointPose{
  	Quaternion m_rot;
  	Vector3 m_trans;
  	Float32_t m_scale;		// 允许统一缩放
      Vector4 m_scale;		// 允许非统一缩放
  };
  
  struct SkeletonPose{
      Skeleton* m_pSkeleton;		// 骨骼+关节数量
      JointPose* m_aLocalPose;	// 多个局部关节姿势，动态分配匹配骨骼内关节数目的JointPose
  }
  ```

- 局部关节姿势是相对于直属父节点指定的，任何仿射变换都可以想象为把点或矢量从一个坐标系变换为另一个坐标系，把关节姿势施加于对应关节，就是把其转换到父节点空间进行表示

#### 11.3.3 全局姿势

- 全局姿势：把关节姿势表示为模型空间或世界空间。有的引擎使用矩阵表示有的使用SQT格式

- 数学上，某关节的模型空间姿势可以从该关节遍历至根关节，在每个关节乘以其局部姿势算出

- 内存中表示全局姿势：

  ```c++
  // 扩展上面的局部姿势
  struct SkeletonPose{
  	Skeleton* m_pSkeleton;		// 骨骼+关节数量
  	JointPOse* m_aLocalPose;	// 多个局部关节姿势
  	Matrix4x4* m_aGlobalPose;	// 多个全局关节姿势
  }
  ```

### 11.4 动画片段

- 游戏中不能预料角色会移动至哪里和怎么移动，所以几乎不能制作成一串很长的、连续的帧，而是被拆分成大量小粒度的动作，称之为动画片段或简称为动画。
- 每个动画片段都能令角色表现一个有明确界定的动作，有的被设计成循环形式，有的只会播放一次。有些会影响全身，有些影响部分。一个角色会分拆为上千个动画片段
- 当角色进入游戏中非互动部分，通常用于交互难于在互动游戏过程中表现的故事情节，制作方法基本上和计算机生成的动画电影相同。被称为游戏内置电影（ingame cinematics，IGC）、非交互连续镜头（noninteractive sequence，NIS）或全动视频（full-motion video，FMV），IGC和NIS通常指游戏引擎来渲染的非互动序列，FMV指预先渲染至MP4、WMV或其他的视频文件类型，然后在运行时由引擎内的全屏电影播放器播放
- 非互动序列的另一个变种为半互动序列，快速反应事件（quick time event，QTE），玩家必须在非互动序列中的正确时间按键才能看到成功的动画并继续下去，否则播放失败的动画或者没有任何变化，在有些情况的会造成一些如减血等不良效果

#### 11.4.1 局部时间线

- 每个动画片段各自有一条局部时间线，该时间线通常使用自变量t表示，开始时t=0，结束时t=片段持续时间，t的每个值称为时间索引
- 把帧展示给观众的速率并不一定等于动画师所在制作的姿势的播放速率，动画师会在片段中指定的时间点上设定一些重要的姿势，称为关键姿势或关键帧，然后计算机采用线性或基于曲线的插值计算中间的姿势
- 由于动画引擎能够对姿势插值，实际上能在片段任何时间采样不一定是整数帧索引，即动画片段的时间线是连续的
- 动画电影不会充分利用动画时间线的连续性带来的好处，因为帧率会锁定为每秒24/30/60帧
- 因CPU或GPU的负载，实时游戏的帧率经常有少许变动，且有时会调节游戏动画时间比例，使角色的动作显得快于或慢于原来制作动画时的速率，因此游戏中动画片段几乎永远不会在整数帧索引上采样
- 由于动画的时间线是连续的、最好使用秒作为时间度量单位，若定义了帧的持续时间那么时间也可以作为帧的度量单位，无论那种时间单位都应该是浮点数、顶点数或测量非常小的子帧时间间隔的整数，让度量值有足够的分辨率以计算帧之间的结果或改变动画播放速率
- 把动画片段设计为不断重复播放时，称之为循环。要令片段好好的循环，片段最后的角色姿势必须完全和最初的姿势匹配，即最后一个刺啊杨是冗余的，多数游戏引擎会略去循环片段的最后一个采样
- 使用归一化的时间单位是比较方便的，无论动画的持续时间为多长，0表示动画开始1表示动画结束，有时成归一化的时间为动画的相位，因为当动画在循环时归一化时间犹如正弦波的相位。要同步两个及以上的动画片段且持续时间不相同时，归一化时间就很有用

#### 11.4.2 全局时间线

- 游戏里每个角色都有一个全局时间线，其时钟在角色诞生于游戏世界时启动或在关卡或整个游戏开始时启动。可以把播放动画简单想象成片段的局部时间映射到角色的全局时间
- 在片段中调整时间比例可以把片段播放的比原来设定的值更快或更慢，只需把片段置于全局时间线上时缩放其比例，该功能最自然的表示方式为播放速率，要将片段倒转播放可以把时间比例设为-1
- 要把动画片段映射至全局时间线，需要以下信息：片段的全局起始时间，播放速率，持续时间，循环次数
  - 若动画非循环：t = clamp(速率 * (全局时间 - 开始时间))
  - 若动画无限循环：t = (速率 * (全局时间 - 开始时间)) mod 持续时间
  - 若有限次循环： t = (clamp(速率 * (全局时间 - 开始时间))) mod 持续时间 

#### 11.4.3 比较局部和全局时钟

- 动画系统必须记录每个正在播放的动画的时间索引：

  - 局部时钟：该方法中每个片段都有其局部时钟，通常用秒、帧、归一化时间为单位，以浮点小数形式存储，片段开始时局部时间t被设为0，随时间推移把每个片段各自的局部时钟向前推进，若片段有非正常的播放速率则推进时要以该速率缩放
  - 全局时钟：角色含有全局时钟，时钟通常以秒为单位，每个片段记录其开始播放时的全局时间，片段的局部时间使用时间映射的方式计算出来而不直接存储在片段之中

  局部时钟方法的优点在于简单且是设计动画系统时最显然的选择，全局时钟方法有其国人指出，特别使用于同步动画，无论是单个角色本身的同步还是场景中多个角色的同步

- 在局部时钟方法中同步两个或以上片段时必须在完全相同的时间播放它们，但若播放动画的命令来自多个不同的引擎子系统时就变的棘手，如一个为玩家操控的攻击一个是AI进行播放受击

- 在全局时钟方法中，只需将两个动画的全局开始时间进行匹配即可，可以根据两个角色全局时钟之差调整两个全局开始时间或简单令游戏中所有角色共享一个相同的主时钟

#### 11.4.4 简单的动画格式

```c++
struct JointPose { SQT };

struct AnimationSample{
	JointPose* m_aJointPose;	// 关节姿势数组
}

struct AnimationClip{
	Skeleton* m_pSkeleton;			// 也可能使用独一无二的标识符，然后用一个方式让标识符可以快速找到骨骼
	Float32_t m_framesPerSecond;
	Uint32_t m_frameCount;
	AnimationSample* m_aSpamles;	// 采样数组
	bool m_isLooping;
}
```

- 每个动画片段都是为特定骨骼设计的，通常不会用于其他骨骼，若多个骨骼是近似的，如一些骨骼含有不会影响主要层次结构的子关节，那么为其中一个骨骼所涉及的动画能应用于其他骨骼，要求是引擎把动画播放于某骨骼时需要忽略动画中未能与骨骼匹配的关节。更先进的技术可以把为一个骨骼设计的动画重定目标至不同的骨骼，这是一个活跃的研究领域

#### 11.4.5 连续的通道函数

- 动画片段中的采样就是用来定义随时间改变的连续函数的，读者可以把动画片段想象为每关节有10个标量或两个矢量加一个四元数矢量值的函数，这些通道函数在整个片段的时间线上是平滑并连续的，但许多游戏引擎只会在采样间进行线性插值，实际上用到的是连续函数的分段逼近

#### 11.4.6 元通道

- 许多游戏允许在动画中加入额外的元通道数据，这些通道可以把游戏专用的信息编码同时能和动画同步且无须把这些信息以骨骼姿势存储
- 常见的一种特殊通道是在多个时间点上存储时间触发器，当动画的局部时间索引经过这些触发器时，触发器的时间便会送交游戏引擎按需处理时间，其常常用于记录在动画中哪些时间点要播放音效或粒子效果
- 另一种常见做法是提供一种在Maya中称为定位器的特殊关节，定位器可以和骨骼关节一起设置动画，其实一个放射变化，所以可以记录游戏中任何物体的位置和定向。其典型用法是在动画中设置摄像机的位置和角度
- 其他非关节动画通道的例子：
  - 纹理坐标滚动
  - 纹理动画
  - 含动画的材质参数
  - 含动画的光源参数
  - 其他随时间改变并以某种形式和动画同步的参数

### 11.5 蒙皮及生成矩阵调色板

#### 11.5.1 每顶点的蒙皮信息

- 蒙皮用的网格是通过其顶点系上骨骼的，每个顶点可绑定至一个或多个关节，若只绑定一个则完全跟随该关节移动，若绑定至多个，则该顶点的位置等于把它逐一绑定至个别关节后的位置，再取加权平均

- 若要把网格蒙皮至骨骼，三维建模师必须替每个顶点提供以下额外信息：

  - 该顶点要绑定到的一个或多个关节索引
  - 对于每个绑定的关节，提供一个权重因子以表示该关节对最终顶点位置的影响力。权重的和为1

- 游戏引擎通常会限制每个顶点能绑定的关节数目，典型的为每顶点4个关节，4个8位关节索引能方便的被包裹为一个32位字，每顶点使用2/3/4个关节所产生的质量相对容易区分，但若每个顶点使用超过4个关节，多数人就不能再分辨出其中的质量差别了

- 典型的蒙皮顶点数据结构：

  ```c++
  struct SkinnedVertex{
  	float m_position[3];		// 位置
  	float m_normal[3];			// 法线
  	float m_u, m_v;				// 纹理坐标
  	uint8_t m_jointIndex[4];	// 关节索引
  	float m_jointWeight[3];		// 权重，省略最后一个
  }
  ```

#### 11.5.2 蒙皮涉及的数学知识

- 蒙皮矩阵：把网格顶点从原来位置（绑定姿势）变换至骨骼的当前姿势。蒙皮矩阵并非基变更变换，其把顶点变形至新位置，变换前后都在模型空间
- 单个关节中顶点从绑定姿势转换到特定姿势：顶点绑定至关节的位置时，在该关节坐标空间中是不变的，因此可以把顶点在模型空间中的绑定姿势转换至关节空间，再把关节移动到特定姿势，然后将顶点转换模型空间，这个转换过程联合起来就是蒙皮矩阵
- 多个顶点从绑定姿势转换到特定姿势：首先计算绑定姿势和特定姿势中特定关节到根关节的矩阵，然后通过上面矩阵计算一组蒙皮矩阵，其中每个矩阵都对应着这特定关节。次数组被称为矩阵调色板，当要渲染一个蒙皮网格，矩阵调色板便要被传送至渲染引擎，为每个顶点查找调色板中合适的关节蒙皮矩阵，并用该矩阵把顶点从绑定姿势变换至当前姿势
- 绑定姿势逆矩阵在整个游戏中都是常量，在模型创建时确定下来的，并不需要在运行时计算，动画引擎通常先计算每个关节的局部姿势，然后把这些矩阵转换至全局姿势，最后把全局姿势乘以对应绑定姿势的逆矩阵以生成每个关节的蒙皮矩阵
- 每个顶点最终都会由模型空间变换至世界空间，因此有些引擎会把蒙皮矩阵调色板预先乘以物体的模型到世界的变换矩阵，这让渲染引擎渲染蒙皮几何时每个顶点能节省一个矩阵乘法
- 把顶点蒙皮至多个关节：计算顶点分别蒙皮至每个关节产生对每个顶点的模型空间位置，然后把这些结果进行加权平均再求出最终位置

### 11.6 动画混合

- 动画混合指能令一个以上的动画片段对角色最终姿势起作用的技术，即将两个或更多的输入姿势结合产生骨骼的输出姿势。也可以用来求出不同时间点的两个已知姿势之间的姿势，使动画平滑过渡

#### 11.6.1 线性插值混合

- 给定含N个关节的骨骼，以及两个骨骼姿势，希望求得此两极端的中间姿势中间姿势。
- 方法之一使用对两个姿势中每个关节的局部姿势进行线性插值，此时整个骨骼的插值后的姿势仅仅是所有关节插值后姿势的集合，此时若存储为矩阵形式则要对变换矩阵进行插值，并非切实可行，所以一般是用SQT来存储然后进行插值，对两个骨骼姿势进行线性插值时最自然的中间姿势通常是令关节独立在其父节点空间进行插值，即姿势混合通常在局部姿势中进行，且意味着可以完全并行的在多处理架构上运行

#### 11.6.2 线性插值混合的应用

- 时间性混合：动画不会在整数求索引，求出特定时间的姿势插值的比例为(当前时间 - 开始时间) / (结束时间 - 开始时间)

- C0连续：角色身体每个部分的动作都是完整流畅的，就算在过渡中也是如此，骨骼中每个关机移动时所描绘出的三维路径不应含突然“跳跃”

  C1连续：第一导数（速度曲线）也应该连续

  C2连续：第二导数（加速度曲线）也是连续的

  达到更高阶的连续会让角色的动作显得更加真实，但通常难以打到数学上严格的C1或以上的连续，但可以使用线性插值的动画混合达到相当不错的C0动作连续性，且可以相当好的逼近C1连续性，当应用到过度片段时可能会产生一些瑕疵如“滑脚”问题

- 若要对两个动画进行淡入/淡出，需要将两个片段的时间线适度的重叠，该重叠部分有时称为混合时间。初始时插值比例为0完全为第一个动画，然后逐步递增到插值比例为1完全为第二个动画

- 两种常见淡入/淡出过渡方法：

  - 平滑过渡：播放片段A及片段B的同时将比例从0至1递增，若想效果较好则两个片段都必须为循环动画，且两个片段都必须时间上同步且手脚位置大致匹配
  - 冻结过度：混合时片段A的局部时间停顿，然后B逐渐取代角色动作，其适合于两个不相关且不能在时间上同步的片段

- 

