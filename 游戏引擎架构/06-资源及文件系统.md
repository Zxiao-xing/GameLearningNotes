### 6.1 文件系统  

- 游戏引擎的文件系统API通常提供一下几类功能：
  - 操作文件名和路径
  - 开、关、读、写单独的文件
  - 扫描目录下的内容
  - 处理异步文件输入/输出请求（做串流之用）

#### 6.6.1 文件名和路径

- 路径是一种字符串，用来描述文件系统层次中文件或目录的位置。每个操作系统都有少许不同的路径格式，但本质上有相同的结构。一般为如下：

  卷/目录 1/目录 2/.../目录N/文件名（或目录）

  即路径通常包含一个可选的卷指示符进阶一串路径成分，之间以路径分隔符分割，若路径指向文件则最后是文件名，否则是目录名

**操作系统之间的区别**

- 微软DOS、微软Windows、UNIX操作系统家族、苹果Macintosh操作系统间的一些重要区别：
  - UNIX使用正斜线符作为路径分隔符（/）；DOS及早期版本的Windows则采用反斜线符（\），较新版的Windows允许以正或反斜线分割路径，但有些应用程序仍不接受正斜线；macOS 8和9采用冒号作为路径分隔符（:），而其是基于UNIX的，所以支持UNIX的正斜线分隔符记号法
  - UNIX及其变种不支持以卷分开目录层次，整个文件系统是以单一庞大的层次组成，本机磁盘、网络磁盘以及其他资源都是mount到主层次中的某棵子树上，因此不会出现卷指示符
  - 在微软Windows中可以用两种方法定义卷，本机磁盘以单英文字母加冒号指明（如C:），远端网络共享则可以挂接成为像本机磁盘一样，或是用双反斜线号加上远端计算机名字和共享目录/资源名指明（如\\\computerName\shaderedFile）
  - 在DOS和早期版本的Windows中，文件名最多只能含8个字符，以点号分隔后有3个字符的扩展名，扩展名描述文件的类型。后期Windows中文件名可包含多个点号（UNIX也可以），但许多应用程序包括Windows资源管理器仍会把最后一个点号后的字符诠释为文件的扩展名
  - 每个操作系统都会禁止某些字符出现在文件和目录名称中。Window或DOS路径中冒号除了出现在卷指示符后不能置于其他地方。有些操作系统允许部分保留字符出现在路径内但整个路径要加上引号，或是在违规字符前加上转义符
  - UNIX和Windows都有当前工作目录（CWD和PWD）的概念。在这两个操作系统的command shell里，都可以用cd命令设置当前工作目录，取得当前目录Window可使用无参数的cd命令，UNIX下执行pwd命令。在UNIX下只有一个当前工作目录，但在Windows下每个卷有其独立的当前工作目录
  - 支持多卷的操作系统（如Windows）也有当前工作卷的概念，在Windows命令行输入表示磁盘的字母加上冒号即可切换当前工作卷
  - 游戏姬通常用一组预定义的路径前缀去表示多个卷。如PS3使用/dev_bdvd/前缀指明蓝光驱动，/dev_hddx/则代表多个硬盘

**绝对路径和相对路径**

- 所有路径都对应文件系统中的某个位置，当路径是相对于根目录的，就称为绝对路径；相对于文件系统层次架构中的其他目录，则称之为相对路径
- 在UNIX和Windows下，绝对路径的首字符为路径分隔符，而相对路径则不会以路径分隔符作为首字符。Windows中，绝对路径和相对路径都可以加入卷指示符，不加入卷指示符代表使用当前工作卷

**搜寻路径**

- 路径是代表文件系统下某文件或目录的字符串。搜寻路径是含一串路径的字符串，各路径间以特殊字符分隔，查找文件时就会从这些路径进行搜寻
- 有些游戏引擎会使用搜寻路径查找资源文件，但在运行时搜寻资产可能是费时的做法，通常资产路径在运行之前就可得知，因此应能完全避免搜寻资产

**路径API**

- 路径比简单字符串复杂的多，程序员需要对路径进行多种操作，如从路径中分离目录/文件名/扩展名，使路径规范化、在绝对路径和相对路径之间进行转换等，含丰富功能的路径API对完成这些任务非常有用
- Windows提供了一组API，有shlwapi.dll动态程序库实现，并提供了shlwapi.h头文件。
- 游戏引擎通常会实现轻量化的路径处理API，符合引擎的特有需求，并能为引擎的所有目标平台工作，其可以是对原生API的简单包装，也可以从零开始实现

#### 6.1.2 基本文件I/O

- 标准C程序库提供了两组API开启、读取以及写入文件内容，一组拥有缓存功能（以f开头），一组无缓冲功能。每次调用输入输出时都需要称为缓冲区的数据区块，以供程序和磁盘之间的传送来源或目的字节，若有API管理该缓冲就称为有缓冲功能的IO，若由程序员负责管理则称为无缓冲功功能的IO。
- 在C标准程序库中，有缓冲功能的有时称为流输入/输出 API，因为这些API把磁盘文件抽象成字节流
- 在UNIX及其变体中标准C程序库的无缓冲IO是原生的操作系统调用，Windows中仅仅是底层API的包装

**包装还是不包装**

- 包装操作系统的IO API有三个好处：
  1. 引擎程序员能保证这些自定义的API在所有目标平台上均有相同的行为，就算某平台上的原生程序库本身有不一致性或bug也是如此
  2. API可以被简化，只剩下引擎实际需要的函数，使维护工作量降到最低
  3. 可提供扩展功能

**同步文件IO**

- C标准库的两种文件IO都是同步的，当程序发出IO请求后biu等待读写完毕才能继续运行

```c++
// 同步IO函数
bool syncReadFile(const char* filePath, uint8_t* buffer, size_t bufferSize, size_t& rBytesRead) {
	FILE* handle = fopen(filePath, "rb");
	if (handle) {
		// 阻塞，直至所有数据读取完毕
		size_t bytesRead = fread(buffer, 1, bufferSize, handle);
		int err = ferror(handle);
		fclose(handle);
		if (err == 0) {
			rBytesRead = bytesRead;
			return true;
		}
	}
	rBytesRead = 0;
	return false;
}
```

#### 6.1.3 异步文件IO

- 串流：在背景载入数据，主程序同时继续运行
- 最常见的串流数据类型可能是音频和纹理，其他数据如集合图形、关卡布局、动画片段等都可以进行串流
- 为了支持串流，必须使用异步文件IO库，该库能在程序请求IO后不需要等待读写完成，程序便可立即继续运行
- 有些操作系统自带异步文件库，如Windows通用语言运行平台（CLR）提供了System.IO.BeginRead()和System.UI.BeginWrite()等函数；PS3和PS4提供了名为fios的异步API。若目标平台不提供异步IO库，只要提供线程或类似功能就可自行实现

```c++
AsuncRequestHandle g_hRequest;	//异步IO请求句柄

uint8_t g_asyncBuffer[512];		//输入缓冲

// 异步读取完成的回调函数
static void AsyncReadComplete(AsuncRequestHandle hRequest) {
	if (hRequest == g_hRequest && AsyncWasSuccessful(hRequest) ){
		size_t bytes = asyncGetBytesReadOrWritten(hRequest);

		char msg[256];
		snprintf(msg, sizeof(msg), "async success, read %u bytes\n", bytes);
		OutputDebugString(msg);
	}
}

int main() {

	AsyncFileHandel hFile = AsyncOpen("C:\\filename.txt");
	if (hFile) {
		// 异步读取
		g_hRequest = asyncReadFile(hFile, g_asyncBuffer, sizeof(g_asyncBuffer, AsyncReadComplete));
	}

	return 0;
}
```

- 多数异步IO库允许主程序在请求发出后一段时间等待IO操作完成后才继续运行（类似于等待协程运行完毕）
- 有些异步IO库允许程序员取得某异步操作所需时间的估算，一些API也可以为请求设置时限（会为待完成的请求划分优先次序），并可设置请求超出时限时的安排

**优先权**

- 文件IO是实时系统，需要遵循时限，因此异步IO常有不同的优先权，必须能暂停较低优先权的请求，让较高优先权的IO有机会在时限到达前完成

**异步文件IO如何工作**

- 异步文件IO是利用另一单独线程处理IO请求的，主线程调用异步函数时，会把请求放入一个队列并立即传回，同时IO线程从队列中取出请求，并以阻塞IO函数处理这些请求，工作完成后调用主线程之前提供的回调函数告知该操作已完成，若主线程选择等待完成IO请求，就会使用信号量处理

### 6.2 资源管理器

- 每个游戏由种类繁多的资源构成，游戏资源必需被妥善管理，包括建立资源的离线工具和在执行器载入、卸下、操作资源
- 每个资源管理器都有两个元件组成，既独立又互相整合。一种负责管理离线工具链，用来创建资产和穿换成引擎可用的形式。另一种在执行期管理资源，确保资源在使用前已被载入内存，并在不需要的时候把它们从内存中卸载

#### 6.2.1 离线资源管理及工具链

**资产的版本控制**

- 小型游戏项目中，资产的管理方式可以是把组织补眼睛的文件以项目特设的目录置于共享网盘中

- 有些游戏团队使用源代码版本控制系统管理资源，美术人员会将美术源文件签入如Perforce类似套件，该方法的最大问题在于数据量大，尤其是艺术文件。多数源文件控制系统都需要把文件从中央版本库复制至用户的本地机器，对于小的套件会使其崩溃。  解决方法可以是使用针对大量数据的商业版本控制系统，或承受该后果，或在版本控制工具上精心制作了一个系统，保证某终端用户只会将其真正需要的文件取至本地机器。

  顽皮狗使用私有工具解决，该工具利用UNIX的符号连接消除数据复制，同时允许每位用户拥有资产版本库的完整本地视图，只要文件未签出，其就是一个符号链接，链接至共享网盘上的主文件，若签出文件则移除符号链接并更换为一个本地文件。理论上也可通过Windows的NTFS joint point实现

**资源数据库**

- 资产需要经过一些资产调节管道（ACP）将资产转换为引擎所需的格式，当流经资产调节管道时，每个资源都需要用一些元数据描述如何对资源进行处理
- 各游戏引擎中资源数据库的形式有巨大差异。如元数据可能被嵌入资产文件本身，或伴随一个小文本文件用于描述如何处理对应资源，或将生成的元数据写进一组XML文件再通过一些自建的图形界面去管理这些文件，或采用真正的关系数据库
- 无论资源数据库采用什么形式，都必须提供以下功能：
  - 能处理多种类型的资源，理想的是以一直的方式处理
  - 能创建新资源
  - 能删除资源
  - 能查看及修改现存的资源
  - 能把资源从一个位置移至硬盘上的另一个位置
  - 能让资源交叉引用其他资源，通知驱动资源管理生成过程及运行时的载入过程
  - 能维持数据库内所有交叉引用的引用完整性，执行所有常见操作后如删除或移动资源仍能保持引用完整性
  - 能保存版本历史，并完成记录改动者及事由的日志
  - 支持不同形式的搜寻

**一些成功的资源数据库设计**

- 虚幻的资源数据库由其万用工具UnrealEd管理，几乎负责一切事务，无论是资源元数据管理、资产创建还是关卡布局，虽有缺点但其最重要的好处在于，UnrealEd是游戏引擎本身的一部分，使UnrealEd能在创建资产之后立即看到资产在游戏中运行时的样子，游戏也可以在UnrealEd中运行，以便能观察资产在其自然环境中的样子，并能看到资产如何在游戏中运行。另一优势是其通用浏览器能让开发者存取引擎支持的一切资源，以单一、整合、一致的界面创建和管理所有类型的资源

  其缺点是所有资源数据存于少量的大型包文件中，这些文件是二进制的，因此并不易利用如CVS、Subversion等版本控制包进行合并，当多位用户希望修改某包文件中的资源时不能合并就是重要问题，就算用户尝试修改不同的资源，同一时间也只能一位用户能锁定该包，其他人必须等候。缓解此问题的方法就是将资源划分为较小的包，但实际上并不能完全根治这个问题

  其引用完整性相当不错，但仍有一些问题，当某资源被重新命令或移动后，所有对该资源的引用会自动维护，方法是产生一个虚拟对象，把旧的资源映射至其新名称/位置。问题是这些虚拟映射对象会限制、累计起来并造成问题，尤其是删除资源时问题会变得十分严重
  
   

​       

