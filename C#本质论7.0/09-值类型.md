- 有两种自定义值类型：结构和枚举
- 值类型：
  - 变量直接包含数据，名称和存储数据的地址相关联。将原始变量的值赋给另一个变量，会在新变量的位置创建原始变量的内存拷贝，两个变量不引用同一个内存位置
  - 定义时不要让值类型消耗太多内存，一般小于16字节
  - 值类型的值一般只是短时间存在，通常作为表达式的一部分，或用于激活方法。这些情况下，值类型的变量和临时值经常存储在栈或寄存器分配的临时存储池中
  - 临时池清理起来的代价低于垃圾回收的堆，不过值类型要比引用类型更频繁的拷贝，会对性能有一定影响
- 引用类型：
  - 引用类型变量的值是对一个对象实例的引用，存储的是内存地址。要访问数据，“运行时”要从变量读取引用，进行解引用才能招到实际包含数据的位置
  - 应用类型的变量关联了两个存储位置：直接和变量关联的存储位置，以及由变量中存储的值引用的存储位置
  - 处理直接与变量或临时值关联的存储位置时，方式和处理值类型变量关联的存储位置没有任何区别
  - 拷贝引用类型的值时拷贝是引用，64位机器只有8字节

### 9.1 结构

- 除了string和object是引用类型，其他所有C#内建类型都是值类型
- 定义自己的值类型使用和定义类及接口相似的语法，值类型使用关键字struct
- C#7.2其可在编译时验证结构只读，只需在struct前添加关键字readonly，编译时发现某个字段非只读或某个属性含赋值方法将报错
- 虽然语言本身未做要求，但最好的实践是使值类型不可变，一旦实例化就不能修改该实例，要修改应创建新实例

#### 9.1.1 初始化结构

- 除了属性和字段，接口还可包含方法和构造函数，但不可包含用户自定义的无参默认构造函数，相反编译器自动生成默认构造函数将所有字段初始化为默认值
- 为确保局部值类型变量被构造函数完整初始化，结构中的每个构造函数都必须初始化结构的所有字段和只读自动实现属性，在C#6.0中初始化只读自动实现属性已经足够，不用初始化它的支持字段，因为该字段未知
- 未初始化结构的所有数据将发生编译时错误
- C#不允许在结构声明中初始化字段
- 若不用new操作符来调用构造函数从而显式实例化结构，结构中的所有数据都隐式初始化为对应数据类型的默认值，但值类型中的所有数据都必须显式初始化来避免编译时错误。为满足结构初始化要求，所有显式声明的字段都必须初始化，这种初始化必须直接进行，初始化属性而不是字段的构造函数将造成编译时错误
- 为引用类型使用new操作符，“运行时”会在托管堆上创建对象的新实例，将所有字段初始化为默认值，再调用构造函数，将对实例的引用以this形式传递，new操作符最后返回对实例的引用，该引用被拷贝到变量关联的内存位置
- 为值类型使用new操作符，“运行时”会在临时存储池中创建对象的新实例，将所有字段初始化为默认值，调动构造函数，将临时值存储位置作为ref变量以this的形式传递，结果是值被存储到临时位置，然后可将该值拷贝到和变量关联的内存位置
- 和类不同，结构不支持终结器，结构以值的形式拷贝，不像引用类型那样具有“引用同一性”，所以难以知道什么时候能安全执行终结器并释放结构占用的非托管资源

#### 9.1.2 使用default操作符

- 编译器为所有值类型生成自动定义的默认构造函数，将值类型初始化为默认状态，所以任何值类型都可合法使用new操作符创建值类型对象的实例，还可使用default操作符生成结构的默认值。default(int)和new int()生成一样的值
- 访问隐式初始化的值类型是有效操作，而访问引用类型的默认值会抛出NullReferenceException异常
- 从C#7.1 起可以直接在实参中给形参为值类型的写default传递默认值，而不用使用default(type)

#### 9.1.3 值类型的继承和接口

- 所有值类型都隐式密封，除枚举之外的所有值类型都派生自System.ValueType，结构的继承链总是从object到System.ValueType到结构
- 值类型也能实现接口，框架内建的许多值类型都实现了IComparaable和IFromattable接口
- System.ValueType规定了值类型的行为，但没有包含任何附加成员，其重写了object的所有虚成员
- 对于值类型，GetHashCode()的默认实现是将调用转发给结构中的第一个非空字段，Equals()大量利用了反射，假如一个值类型在集合中频繁使用，尤其是使用了哈希码的字典类型的集合，那么值类型应该同时包含对Equals()和GetHashCode()的重写以获得好的性能

### 9.2 装箱

- 值类型转换成它实现的某个接口或object，结果必然是对一个存储位置的引用，该位置表面上包含引用类型的实例，但实际包含值类型的值。这种转换称为装箱
- 从值类型的变量转换成引用类型会涉及以下几个步骤：
  - 在堆上分配内存，将用于存放值类型的数据以及少许额外开销（SyncBlockIndex和方法表指针），这些开销使对象看起来像引用类型的托管对象实例
  - 接着发生一次内存拷贝动作，当前存储位置的值类型数据拷贝到堆上分配好的位置
  - 最后，转换结果是对堆上的新存储位置的引用
- 相反的过程称为拆箱：核实已装箱的类型兼容于要拆箱成的值的类型，再拷贝堆中存储的值，结果是堆上存储的值的拷贝
- 装箱会影响性能和行为，装箱或拆箱如果不是很频繁，性能问题不大， 但有时装箱容易被忽视，而且会非常平凡，这可能大幅度影响性能，每次装箱都涉及内存的分配和拷贝，每次拆箱都涉及类型检查和拷贝
- C#支持用于同步代码的lock语句，该语句实际编译成System.Threading.Monitor的Enter()和Exit()方法，两个方法必须成对调用。Enter记录由其唯一的引用类型参数传递的一个lock，这样使用同一个引用调用Exit时就可释放该lock。值类型的问题在于装箱，每次调用Enter或Exit都会在堆上创建新值。将一个拷贝的引用同另一个拷贝的引用比较总是返回false，无法将Enter和对应的Exit钩在一起，不允许在lock语句中使用值类型
- 在方法调用期间避免装箱：
  - 任何时候在值类型上调用方法，接受调用的值类型（this）必须是变量而不是值，因为方法可能尝试修改接收者，显然它必须修改接受者的存储位置而不是修改接收者的值的拷贝再丢弃该拷贝
  - 在需要值类型的变量但只有一个值可用的情况下，会发生以下两件事之一：要么是C#编译器生成代码来创建一个新的临时存储位置，将值从箱子拷贝到新位置，使临时存储位置称为所需的变量，要么不允许该操作并报错
  - 在已装箱值类型上调用接口方法，所有这些开销都可避免，这时预期的接收者是箱子中的存储位置。执行类型检查、分配新的临时存储和生成拷贝的开销不再需要，“运行时”直接将箱子中的存储位置作为结构方法的调用者
- 若将值类型的实例作为接收者来调用object声明的虚方法的ToString()：
  - 若接收者已拆箱，且重写了该方法，将直接调用重写的方法
  - 若接受这已拆箱，但没有重写该方法，则调用基类的实现，该实现逾期的接收者是一个对象引用，所以该接收者被装箱
  - 若接受已装箱，且重写该方法，就将箱子中的存储位置传给重写方法而不拆箱
  - 若接收者已装箱，且没有重写该方法，就将对箱子的引用传给基类的实现

### 9.3 枚举

- 枚举是可由开发者声明的值类型，枚举的关键特征是在编译时声明了一组具名常量值，是代码更易读

- 使用枚举值需要为其附加枚举名称前缀，所以枚举值的名称尽量不要包含枚举名称

- 根据约定，除了位标志之外的枚举名称应该是单数形式

- 枚举值实际作为整数常量实现，默认第一个枚举值是0，后续每一项都递增1，但可以显式的为枚举赋值

  ```c#
  enum ConnectionState{
  	Disconnected,			//0
  	Connecting = 10			//10
  }
  ```

- 枚举总是具有一个基础类型，可以是除char之外的任意整型，枚举类型的性能完全取决于基础类型的性能，默认基础类型是int，但可以用继承语法指定其他类型

  ```c#
  enum ConnectionState : short{
  	Disconnected,
  	Connecting
  }
  ```

- 所有枚举的基类都是System.Enum，后者从System.ValueType派生

- 枚举类型都是密封的，不能从现有枚举类型派生以添加额外成员

- 枚举不过是基础类型上的一组名称，对于枚举类型的变量，它的值不限于声明中命名的值。枚举类型也能转变成整型，整型能转变成枚举类型，即使枚举类型中不存在该值。该设计的优点在于可在未来的API版本中为枚举添加新值且不会破坏早期版本。枚举值为已知值提供了名称，且允许在运行时分配未知的值，该设计的缺点在于编码时须谨慎，要主动考虑到未命名值的可能性

- 从枚举转换到基础类型或者从基础类型转换到枚举都需要显式转型，唯一的例外是传递0，0能隐式转换成任何枚举

- 在枚举中部插入枚举值，会使其后的所有枚举值发生瞬移，这回影响根据新枚举来重新编译的所有版本，但任何基于旧枚举编译的代码都会继续使用旧值，除了在列表末尾插入新的枚举值，避免旧的枚举值改变的另一个方法是显示赋值

#### 9.3.1 枚举之间的类型兼容性

- C#不支持不同枚举数组之间的直接转型，但CLR允许，前提是两个枚举具有相同的基础类型，为避开C#的限制，技巧是先转型为System.Array，其利用了CLR的赋值兼容性比C#宽松这一事实。还可以利用同样的技巧进行非法转换，如int[]转换成uint[]，但使用该技巧务必慎重，因为C#规范没有说这个技巧在不同CLR实现中都能发挥作用

#### 9.3.2 在枚举和字符串之间转换

- 枚举的一个好处是ToString()方法会输出枚举值标识符

- 字符串向枚举的转换通过System.Enum.Parse()静态方法，第一个参数是类型，用关键字typeof()指定，这是在编译时判断类型的一种方法，可把它看成类型值的字面值。在.NET Framework 4的TryParse\<T\>()方法使用了泛型，但类型参数可以推断出来，所以可以省略

  ```c#
  if(Enum.TryParse("Idle", out priority)){
      
  }
  ```

- 从字符串像枚举的转换都是不可本地化的，所以若本地化是一项硬性要求，只有对那些不公开给用户的消息，开发人员才可进行这种形式的转换

#### 9.3.3 枚举作为标志使用

- 若希望能对枚举值进行组合表示复合值，可以将枚举值定义为位置唯一的二进制位。使用按位或操作符联接枚举值，使用HasFlags()（.NET Framework 4.0）方法或按位与操作符测试特定位是否存在

- 一个好习惯是在标志枚举中包含值为0的None成员，因为无论枚举类型的字段还是枚举类型的一个数组中的元素，其默认初始值都是0

- 避免最后一个枚举值对应像Maximum这样的东西，因为其可能被解释称有效枚举值

- 要检查枚举是否包含某个值，使用System.Enum.IsDefined()方法

- 若决定使用位标志枚举，枚举的声明应该用FlagsAttribute（可以使用Flags简化名称）来标记，该特性应包含在一对方括号中，并放在枚举声明之前。该特性支持枚举值可以组合。还改变了ToString()和Parse()方法的行为，为用FlagsAttribute修饰的枚举调用ToString()方法，会为已设置的每个枚举标志输出对应字符串

  