### 10.1 重写object的成员

#### 10.1.1 重写ToString()

- 在对象上调用ToString()默认返回类的完全限定名称，可重写ToString()输出比默认实现更有意义的信息，特别是目标用户是开发者
- 要使ToString返回的字符串简短
- 不要从ToString()返回空字符串来代表空
- 避免ToString()引发异常或造成可观察到的副作用（改变对象状态）
- 若要返回值与语言文化相关或要求格式化，就要重载ToString或实现IFormattable

#### 10.1.2 重写GetHashCode()

- 只要重写Equal就要重写GetHashCode，否则编译器会显示警告。将类作为哈希表集合的键使用也应重写GetHashCode

- 哈希码的作用是生成和对象值对应的数字，从而高效的平衡哈希表，即提供良好的随机分布，使哈希表获得最佳性能

- 实现原则：

  1. 必须：
     - 相等的对象必然有相等的哈希码
     - 在特定对象的生存期内，GetHashCode始终返回相同的值，即使对象的数据发生了改变。许多时候应用缓存方法的返回值确保这一点
     - GetHashCode不引发任何异常，总是成功的返回一个值
  2. 性能：
     - 哈希码应尽可能唯一，但由于哈希码只是返回一个int，所以只要一种对象包含的值比一个int能够容纳得多，就必然重复
     - 坑呢的哈希码值应当在int返回内平均分布
     - GetHashCode的性能应该优化，其通常在Equals实现中用于“短路”的一次完整的相等性比较。所以当类型作为字典集合中的键类型使用时，会频繁调用
     - 两个对象的细微差异应造成哈希值的极大差异。理想情况下，1 bot的差异应熬成哈希码平均16bit的差异，这有助于确保不管哈希表如何对哈希值进行“装桶”也能保持良好的平衡性
  3. 安全性：
     - 攻击者应难以伪造具有特定哈希码的对象。攻击手法是向哈希表中填写大量哈希为同一个值的数据，若哈希表的实现不高效，就易受到DOS（拒绝服务）攻击

  许多原则是相互对立的，很难有一种哈希算法既快又满足所有这些要求，好的解决方案必然是综合考虑的结果

- 实现GetHashCode：一般方案是向成员的哈希码应用XOR操作符，并确保操作数不相近或相等，否则结果全为0，在操作符相近或相等的情况下，考虑改为使用移位或加法操作，其他备选的操作符AND和OR具有类似的限制，多次应用AND会逐渐变为0，多次应用OR会逐渐变为1。为进行更细致的控制，应使用移位操作符分解比int大的类型。若基类不是object，应在XOR赋值中包含base.GetHashCode()

- 若参与执行哈希码计算的每个字段都只读，所以值不会变，但假如计算得到的值可能改变，或在缓存值之后能显著优化性能，就应该对哈希码进行缓存

#### 10.1.3 重写Equals

- 两个引用若引用同一个实例，就说会这两个引用是同一的，object提供名为ReferenceEquals()的静态方法来显式检查对象的同一性
- 两个对象实例的成员值部分或全部相等也可以说它们相等
- 为值类型调用ReferenceEquals总是返回false，因为转换成object时要装箱，即使ReferenceEquals的两个参数传递同一个值类型变量，结果也是false，因为两个值会单独装箱
- 重写Equals的步骤：
  1. 检查是否为null
  2. 若是引用类型，检查引用是否相等
  3. 检查数据类型是否相同
  4. 调用一个指定了具体类型的辅助方法，它的操作数是具体要比较的类型而不是object
  5. 可能要检查哈希码是否相等来短路一次全面的、逐字段比较
  6. 若基类重写了Equals，就检查base.Equals
  7. 比较每一个关键字段，判断是否相等
  8. 重写GetHashCode
  9. 重写==和!=操作符

#### 10.1.4 用元组重写GetHashCode和Equals

- 对Equals可将每个关键成员合并到一个元组中，并将它们和同类型的目标实参比较
- 元组内部使用了EqualityComparer<T\>，它依赖IEquatable<T\>的类型参数实现，所以重写Equals要实现IEquatable<T\>，这样自定义数据类型将使用自定义实现而不是Object.Equals
- GetHashCode只需要实例化所有这些成员的一个元组，返回该元组的GetHashCode结果

### 10.2 操作符重载

- 除了x.y、f(x)、new、typeof、default、checked、unchecked、delegate、is、as、=、=>之外，其他所有操作符都允许为任何类和结构添加
- 重载的操作符无法通过IntelliSense呈现，除非故意要使类型表现的想基元类型，否则不要重载操作符

#### 10.2.1 比较操作符（==、!=、>、<、>=、<=）

- 这些操作符的实现可以将逻辑委托给Equals进行，但要执行一些初始的null检查
- 不要用相等性操作符执行空间插，否则会递归调用方法，造成只有栈溢出才会终止的死循环，应调用ReferenceEquals检查是否为空

#### 10.2.2 二元操作符（+、-、*、/、%、&、|、^、<<、>>）

- +、-、*、/、%、&、|、^、<<、>>操作符都用二元静态方法实现，其中至少有一个参数的类型是包容类型（当前正在实现该操作符的类型），方法名由operator加操作符构成

#### 10.2.3 二元操作符复合赋值（+=、-=、*=、/=、%=、&=、...）

- 只要重载了二元操作符，就自动重载了其复合赋值形式

#### 10.2.4 条件逻辑操作符（&&、||）

- 条件逻辑操作符不能显式重载，但由于逻辑操作符&和|可以重载，而条件操作符由逻辑操作符构成，所以实际能间接重载条件操作符，x && y可以作为 x & y，其中y必须求值为true，类似的在x求值为false的时候，x||y可以作为x|y处理。要允许类型求值为true或false，要重载true/false一元操作符

#### 10.2.5 一元操作符（+、-、！、~、++、--、true、false）

- 一元操作符的重载和二元操作符相似，当只获取一个参数，该参数必须是包容类型
- 冲在true和false时两者都要重载，签名和其他操作符重载相同，但返回必须是bool值

#### 10.2.6 转换操作符

- C#允许定义方法来处理一种类型向另一种类型的转型，还允许在方法声明中指定该转换是隐式的还是显式的
- 定义转换操作符在形式上类似于定义其他操作符，只是“operator”后成了转换的结果类型，operator要放在表示隐式或显式转换的implicit或explicit关键字后面
- 实现转换操作时，为保证封装性，要么返回值，要么参数必须是包容类型，C#不允许在被转换类型的作用域之外指定转换

#### 10.2.7 转换操作符规范

- 定义隐式和显示转换操作符差别主要在于，后者能避免不小心指定的隐式转换，造成不希望的行为
- 会引发异常的转换始终都应该是显示的，任何转换只要会丢失数据而且不能成功转换回原始类型的也应该定义为显式的

### 10.3 引用其他程序集

- 不需要将所有代码都放到单独一个二进制文件中，C# 和底层 CLI 平台允许将代码分散到多个程序集中，这样可在多个可执行文件中重用程序集
- 开发者可将程序的不同部分转移到单独的编译单元中，这些单元称为类库或简称为库，然后程序可引用并依赖于类库来提供自己的一部分功能
- 

### -10.5（未完成）

### 10.6 垃圾回收

- 垃圾回收是“运行时”的核心功能，旨在回收不再被引用的对象所占用的内存，垃圾回收器值回收内存不处理其他资源

- 垃圾回收器根据是否存在任何引用来决定要清理什么，即处理的是引用对象，只回收堆上的内存，且假如维持对一个对象的引用，就会阻止垃圾回收器重用对象的内存

- 垃圾回收期的许多细节都依赖于CLI框架

- Microsoft .NET的垃圾回收器采用mark-and-compact算法（mark指可达，compact指移动）。

  一次垃圾回收周期开始时，它识别对象的所有根引用，根引用来自静态变量、CPU寄存器以及局部变量或参数实例、f-reachable对象的任何引用。基于该列表，垃圾回收器可遍历每个根引用所标示的树形结构，并递归确定所有根引用指向的对象，垃圾回收期就可识别出所有可达对象。

  执行垃圾回收时，垃圾回收器不是枚举所有访问不到的对象，它将所有可达对象紧挨着放在一起，从而覆盖不可访问的对象所占用的内存

  为定位和移动所有可达对象，系统要在垃圾回收器运行期间维护状态的一致性，进程中的所有托管线程都会在垃圾回收期间暂停，这显然会造成应用程序出现短暂的挺短，但除非垃圾回收周期特别长，否则该停顿不会引人注意。为尽量避免在不恰当时间执行垃圾回收，System.GC对象包含一个Collect()方法，可在执行关键代码之前调用它，虽然不会阻止垃圾回收器运行，但会显著减少它运行的可能性，前提是关键代码执行期间不会发生内存被大量消耗的情况

  .NET的垃圾回收的特别之处在于，并非所有的垃圾都一定会在一个垃圾回收周期中清除。研究对象的生存期，发现相较于长期存在的对象，最近常见的对象更有可能需要垃圾回收，为此.NET垃圾回收器支持“代”的概念，它会以更快的频率尝试清除生存时间较短的对象，而那些在一次垃圾回收中“存活”下来的对象会以较低的频率清除。共有3代对象，在第一代存活下来的对象会移动到下一代

- 强引用维持着对象的可访问性，阻止垃圾回收器清除对象所占用的内存

- 弱引用不阻止对对象进行垃圾回收，但会维持一个引用

- 弱引用是为创建起来代价较高，而且维护开销特别大的对象而涉及的，其相当于对象的一个内存缓存，缓存中的对象可被快速获取

- 若认为对象或对象集合应该进行弱引用，就将其赋给System.WeakReference

- 创建弱引用之后，可查看弱引用是否为null来检查垃圾回收，先要将弱引用赋值给一个强引用，避免在“检查null值”和“访问数据”这两个动作之间，垃圾回收器运行并清除弱引用

### 10.7 资源清理

#### 10.7.1 终结器

- 终结器允许程序员写代码来清理类的资源，但和使用new的显示调用构造函数不同，终结器不能从代码中显示调用，没有和new对象的操作符。垃圾回收器负责调用终结器，唯一确定的是终结器会在对象最后一次使用之后，并在引用程序正常关闭前的某个时间点运行，若异常终止，则终结器不会执行
- 终结器的声明和C++的析构器语法完全一致，终结器声明要求在类名之前添加一个~字符
- 终结器不允许传递任何参数，所以不可重载，为终结器添加访问修饰符没有意义，也不支持，基类中的终结器作为对象终结调用的一部分被自动调用
- 由于垃圾回收器负责所有内存管理，终结器不负责回收内存，它们负责释放像数据库连接和文件句柄这样的资源，这些资源通过一次显式的行动来清理，而垃圾回收器不知道具体如何采取这些行动
- 终结器在自己的线程中执行，这使它们的执行变的更不确定，这种不确定使终结器中（调试器除外）未处理的异常变得难以诊断，因为造成异常的情况是不明朗的，所以一定在终结器中避免异常为此需要采取一些防卫性编程技术，例如空值检查