

- 现代计算机系统由一个或多个处理器、主存、硬盘、打印机、键盘、鼠标、显示器、网络接口以及各种其他输入/输出设备组成。一般而言现代计算机系统是一个复杂的系统

- 操作系统：认为是为用户程序提供一个更好、更简单、更清晰的计算机模型并管理所有计算机的硬件设备

- 用户与操作系统交互的程序，基于未婚本的称为shell，基于图标的称为图形用户界面（Graphical User Interface，GUI），实际上并不是操作系统的一部分，尽管这些程序使用操作系统来完成工作

- 多数计算机有两种运行模型：

  - 内核态（管态、核心态）：具有对所有硬件的完全访问权，可以执行机器能够运行的任何指令。软件中最基础部分的操作系统，运行在内核态
  - 用户态。只使用了机器指令中的一个子集，特别的那些会影响机器的控制或可进行I/O操作的指令在用户态下是禁止的。除操作系统的其余部分都运行在用户态

  内核态和用户态的主要区别在于用户可以更改用户态的东西，但没有权限修改内核态的程序。但有时在嵌入式系统（没有内核态）或解释系统（采用解释方式并非硬件方式区分组件）中，该区别比较模糊。在许多系统中一些在用户态下运行的程序协助操作系统完成特权功能，但该程序不是操作系统一部分，必须以莫衷方式给予保护，在某些系统中该想法被推向了机制，一些传统上被认为是操作系统的部分（如文件系统）在用户空间中运行，该类系统中很难划分出一条明显的界限，一些在内核外运行的程序也有争议的认为是操作系统的一部分或至少与操作系统密切相关

- 操作系统相比于用户程序更大型、复杂、以及长寿（因为很难编写，开发者不轻易丢弃）

### 1.1 什么是操作系统

- 操作系统有两个基本任务：为应用程序提供一个资源集的清晰抽象，管理硬件资源。所以操作系统是一个运行在内核态的软件并不总是符合事实
- 将操作系统看做向用户提供基本抽象的概念是一种自定向下的观点，操作系统用来管理一个复杂系统的各个部分是一个自定向上的观点

#### 1.1.1 作为扩展机器的操作系统

- 在机器语言一级上，多数计算机的体系结构（指令集、存储组织、I/O和总线结构）是很原始的且编程困难，尤其对于输入/输出操作而言。硬件提供了硬件驱动的软件和硬件进行交互，操作系统还在其之上构建了抽象。
- 抽象是管理复杂性的一个关键，好的抽象可以把一个几乎不可能管理的任务划分为两个可管理的部分：有关抽象的定义和实现、随时用这些抽象解决问题
- 操作系统的一个主要任务是隐藏硬件，呈现给程序良好、清晰、优雅、一致的抽象
- 操作系统的实际用户是应用程序，它们直接与操作系统及其抽象打交道，最终用户与用户接口所提供的抽象打交道或是命令行shell或图形接口

#### 1.1.2 作为资源管理者的操作系统

- 操作系统的任务是在相互竞争的长须之间有序的控制对处理器、存储器以及其他I/O接口设备的分配
- 现代操作系统允许同时在内存中运行多道程序。当一个计算机或网络有多个用户时，管理和保护存储器、I/O设备以及其他资源的需求就很强烈，用户间可能个会互相干扰，且用户不仅共享硬件还要共享信息。
- 操作系统的主要任务是记录哪个程序在使用什么资源，对资源请求进行分配、评估使用代价，并为不同程序和用户调解互相冲突的资源请求
- 资源管理包括两种方式实现多路复用共享资源
  - 时间复用：当一种资源在时间上复用时不同程序或用户轮流使用它，先是第一个获得资源的使用然后下一个，一次类推
  - 空间复用：每个用户都得到资源的一部分从而取代时间复用中的用户排队。

### 1.2 操作系统的历史

**注：作者表明有些是假设的开始和终结时间**

- 第一台真正的数字计算机是英国数学家Charles Babbage设计，其试图建造自己的分析机，但其未能让机器正常运转，因为是一台纯机械数字计算机，当时不能生产出所需要的高精度齿轮，该机器没有操作系统。该数学家雇佣了第一个程序员Ada Lovelace，程序设计语言Ada以她命名

#### 1.2.1 第一代（1945-1955）：真空管和穿孔卡片



### 1.3 计算机硬件简介

#### 1.3.1 处理器

- 计算机的“大脑“是CPU，其从内存中取出指令并执行。在每个CPU基本周期中，首先从内存中取出指令，解码以确定其类型和操作数，最后执行。

- 每个CPU都有一套可执行的专门指令集，所以x86处理器不能执行ARM程序，反之亦然。

- 用来访问内存以得到指令或数据的时间要比执行指令花费的时间长的多，因此所有CPU内部都有一些用来保存关键变量和临时数据的寄存器，通常在指令集提供一些指令用以将一个字从内存调入寄存器，以及将一个字从寄存器存入内存，其他指令可以把来自寄存器、内存的操作数组合或用两者产生一个结果

- 除了用来保存变量和临时结果的通用寄存器，多数计算机还有一些对程序员可见的专用寄存器：

  - 程序计数器：保存了将要取出的下一条指令的内存地址，在指令取出之后程序计数器就被更新以便指向后继的指令
  - 堆栈指针：指向内存中当前栈的顶端，该栈包含了每个执行过程的栈帧，一个过程的栈帧中保存了有关的输入参数、局部变量以及没有保存在寄存器的临时变量
  - 程序状态字（Program Status Word，PSW）寄存器：包含了条件码位（由比较指令设置）、CPU优先级、模式（用户态或内核态）、其他控制位。用户通常读入整个PSW但只对其中少量字段写入

  操作系统必须知晓所有的寄存器，在时分多路复用CPU中，每次停止一个运行着的程序时，操作系统必须保存所有的寄存器值，在稍后该程序被再次运行时可以把这些寄存器重新装入

- 为了改善性能，CPU设计师早放弃了读取、解码、执行一条指令的简单模型。许多现代CPU具有同时取出多条指令的机制即流水线，每个CPU有单独的取址单元、解码单元、执行单元，在第n条指令执行时，第n+1条在解码，第n+2条可以取址。流水线使得编译器和操作系统的编写者很头疼，它造成了机器中实现这些软件复杂性的问题，而机器必须处理这些问题

- 超标量CPU：拥有多个执行单元，不同执行单元拥有不同的运算。两个或多个指令被同时取出、解码并装入暂存缓冲区，只要有一个执行单元空闲，就检查缓冲区中是否还有可处理的指令，若有就把指令从缓冲区中移出并执行。该设计中程序的指令经常不按顺序执行，多数情况下硬件负责保证这种运算的结果与顺序执行时结果相同，但仍有部分复杂情形被强加给操作系统处理

- 通常PSW中有一个二进制位控制内核态和用户态。在内核态运行时，CPU可以执行指令集中的每一条指令，并且使用硬件的每种功能。在用户态运行时，有关I/O和内存保护的所有指令是禁止的，将PSW中的模式位设置为内核态也是禁止的

- 为了从操作系统中获得服务，用户程序必须使用系统调用以陷入内核并启用操作系统，TRAP指令把用户态切换成内核态并启用操作系统，当有关工作完成之后，在系统调用后面的指令把控制权返回个用户程序。计算机使用陷阱而不是一条指令来执行系统调用，其他的多数陷阱是由硬件引起的，用于警告有异常情况发生，在所有的情况下操作系统都得到控制权并决定如何处理异常情况，有时由于出错的原因程序不得不停止，其他情况下可以忽略出错。若程序已经提前宣布它希望处理某类条件，那么控制权还必须返回给该程序让其处理相关问题

- Intel Pentium 4引入了被称为多线程或超线程的特性，其允许CPU保持超过一个的线程状态，在纳秒级的时间尺度内来回切换

- 多核指包含了多个内核的CPU芯片，每个小芯片都是一个独立的CPU

- 现代GPU指由成千上万个微核组成的处理器，它们擅长处理大量并行的简单计算，但不太能胜任串行任务且很难编程，虽然GPU对操作系统很有用但操作系统本省不太可能运行在GPU上

#### 1.3.2 存储器

- 存储器系统采用一种分层次的结构，顶层的存储器速度较高容量较小，与底层的存储器相比每位成本较高，其差别往往是十亿数量级

- 存储器系统：

  - 顶层是CPU中的寄存器，用与CPU相同的材料制成所以和CPU一样快

  - 第二层是高速缓存，多数由硬件控制。主存被分割成告诉缓存行，其典型大小为64字节，地址0至63对应告诉缓存行0。最常用的高速缓存行放置在CPU内部或接近CPU的高速缓存中，当一个程序需要读一个存储字时高速缓存硬件检查所需要的高速缓存行是否在高速缓存中，若在称为告诉缓存命中，缓存满足了请求就不需要通过总线把访问请求送往内存。告诉缓存命中通常需要两个时钟周期，未命中就必须访问内存需要付出大量时间代价

    只要存在大量的资源可以换分为小的部分，那么某些部分就会比其他部分更频繁的使用，通常缓存的使用就会带来性能上的改善

    缓存是一种好方法，所以现代CPU设计了两个缓存（也有三个）：

    - L1缓存总是在CPU中，通常用来将已解码的指令调入CPU的执行引擎，对于那些频繁使用的数据字，多数芯片安排有第二个L1缓存
    - L2缓存用来存放近来使用过的若干兆字节的内存字

    L1和L2缓存之间的差别在于时序，对L1缓存的访问不存在任何延时，对L2缓存的访问则会延时1或2个时钟周期

  - 第三层是主存，是存储器系统的主力，通常称为随机访问存储器（RAM），过去称为磁芯存储器（20世纪5/60年代使用很小的可磁化的铁磁体制作主存）

  - 磁盘

- 除主存之外，许多计算机还在使用少量的非易失性的随机访问存储器，与RAM不同是在电源切断之后不会丢失其内容“

  - 只读存储器（ROM）在工厂中就被编程完毕然后再也不能修改，其速度快且便宜，在有些计算机中将用于启动引导的加载模块放在ROM中，一些I/O卡也采用ROM处理底层设备控制
  - 电可擦除可编程ROM（EEPROM）和闪存可以擦除和重写，但重写需要它们比写入RAM更高数量级时间，所以一般使用与ROM相同，但它们有可能通过字段重写的方式纠正所保存程序中的错误。闪存在速度上介于RAM和磁盘之间，且其擦除次数过多就被磨损

- 还有类易失性的存储器是CMOS，许多计算机利用CMOS存储器保持当前时间和日期，CMOS存储器和递增时间的时钟电路由一块小电池驱动，所以即使计算机没上电时间也仍然可以正确更新。CMOS还可以保存配置参数，因为它消耗电能非常少，一块工厂原装的电池往往能使用若干连，但当电池开始失效时计算机就会丢失这些配置参数

#### 1.3.3 磁盘

- 位于存储器系统最底层，同RAM相比，每个二进制位的成本低了两个数量级，且经常也有两个数量级大的容量，唯一的问题是随机访问数据时间大约慢了三个数量级，因为其是一种机械装置
- 在一个磁盘中有一个或多个金属盘片，以一个速度旋转。从边缘开始有一个机械臂悬横在盘面上，信息写在磁盘的一系列同心圆上。在任意一个给定臂的位置，每个磁头可以读取一段环型区域，称为磁道。把一个给定臂的位置上所有磁道合并起来组成一个柱面。每个磁道划分为若干扇区，现代磁盘中较外部的柱面比较内部的柱面有更多的扇区。
- 固态硬盘（SSD）不是磁盘的磁盘，并没有可以移动的部分，数据是存储在闪存中的，与磁盘相似的地方是它也存储了大量即使在电源关闭时也不会丢失的数据

#### 1.3.4 I/O设备

