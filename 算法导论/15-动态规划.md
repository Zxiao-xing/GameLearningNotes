- 动态规划算法对每个子问题只求解一次，将其解保存在一个表格中，从而无需每次求解一个子问题时都需要重新计算，避免了不必要的计算工作。

- 动态规划方法通常用来求解最优化问题，这类问题可以有很多可行解，每个解都有一个值，希望寻找具有最优值的解，称这样的解为”一个“最优解，因为可能有很多解都达到最优值

- 通常用四个步骤设计一个动态规划算法：

  1. 刻画一个最优解的结构特征
  2. 递归的定义最优解的值
  3. 计算最优解的值，通常采用自底向上的方法
  4. 利用计算的信息构造出一个最优解

  若仅仅需要一个最优解的值，而非解本身（即最优解包含了哪些元素）则可以忽略步骤4

- 动态规划有两种等价的实现方法：

  1. 带备忘的自顶向下法，该方法仍按自然的递归形式编写过程，但过程会保存每个子问题的解，当需要一个子问题的解时过程首先检查是否已经保存过此解，若有则直接返回值从而节省计算时间，否则按通常的方式计算出该子问题
  2. 自底向上法，一般需要恰当定义子问题的规模的概念，使得任何子问题的求解都只依赖于更小的子问题的求解。因而可以将子问题按规模排序，按由小至大的顺序进行求解，当求解某个子问题时，它所依赖的更小的子问题已经求解完毕，结果已经保存。

  两方法得到的算法具有相同的渐进运行时间，仅有的差距是在某些特殊情况下，自定向下方法并未真正的考察所有可能的子问题，且由于没有频繁的递归函数调用的开销，自底向上方法的时间复杂性函数通常有更小的系数

- 子问题图可以准确的表达子问题及子问题之间的依赖关系。其实一个有向图，每个顶点唯一的对应一个子问题，若求子问题x的最优解时需要直接用到子问题y的最优解，那么在子问题图中就会有一条从子问题x的顶点到子问题y的顶点的有向边。

  若x到y有一个有向边，则自顶向下法中求解x时需要递归调用自身来求解y

  自底向上顺序为，对于子问题x，求解它之前求解邻接至它的子问题y

- 子问题图G=(V, E)的规模可以帮助确定动态规划算法的运行时间，由于每个子问题只求解一次，因此算法运行时间等于每个子问题求解时间之和。通常一个子问题的求解时间与子问题图中对应顶点的度（出射边的数目）成正比，而子问题的数目等于子问题图的顶顶啊数，通常情况下动态规划算法的运行时间与顶点和边的数量呈线性关系

### 15.1 钢条切割问题

**问题描述：**给定一段长度为n英寸的钢条和一个价格表pi，求切割钢条方案，使得销售收益rn最大。

- 该问题满足最优子结构性质，问题的最优解由相关子问题的最优解组合而成，而这些子问题可以独立求解

**方法一：暴力搜索法**

- 思路：

  - 1：n英寸的钢条可以先分左边为1，然后递归找出右边1到n-1的最优解，然后左边分2，递归找出右边1到n-2的最优解，直到左边分为n。
  - 2：n英寸的钢条可以分为n和0、n-1和1、n-2和2直到n/2和n/2+1，划分成n/2个子问题从中找出最优解，对这些子问题再进行划分找出最优解，直到划分为长度为1英寸为止

  两方法都是差不多

```c++
// 思路1
int p[N];
int CutRod(int n){
	if(n == 0) return 0;
	int ret = -1;
	for(int i = 1; i <= n; i++){
		ret = max(ret, p[i] + CutRod(n-i));
	}
	return ret;
}
// 思路2
int p[N];
int CutRot(int n){
    if(n == 1) return p[1];
    int ret = -1;
    for(int i = 0; i <= n / 2; i++){
        ret = max(ret,Cut(i) + CutRot(n-i));
    }
    return ret;
}
```

**方法二：动态规划**

- 思路与暴力搜索相似，只是使用了空间存储已经计算过的过程

```c++
// 带备忘录的自顶向下
int p[N];
int dp[N] = -1;
void MemoizedCutRod(int n){
	return MemoizedCutRodAux(n);
}

int MemoizedCutRodAux(int n){
	if(dp[n] >= 0) return dp[n];
	int res = 0;
	if(n == 0)
		res = 0;
	else
		res = -1;
	for(int i = 1; i <= n; i++){
		res = max(res, p[i]+MemoizedCutRodAux(n-i));
	}
	r[n] = res;
	return res;
}
// 自底向上
int p[N];
int dp[N] = -1;
void ButtomUpCutRod(int n){
	dp[0] = 0;
    int res = -1;
    for(int i = 1; i <= n; i++){
        for(int j = 1; j <= i; j++){
            res = max(res, p[j] + dp[i-j]);
        }
        dp[i] = res;
    }
	return dp[n];
}
// 获取最优解，自底向上
int p[N];
int dp[N];
int s[N];
ExtendedButtomUpCutRod(int n){
    int res = -1;
    for(int i = 1; i <= n; i++){
        res = -1;
        for(int j = 1; j <= i; j++){
            if(res < dp[j] + dp[i-j]){
                res = dp[j] + dp[i-j];
                s[i] = j;
            }
        }
        dp[i] = res;
    }
    return res;
}
```

