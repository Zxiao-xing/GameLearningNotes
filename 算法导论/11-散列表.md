- 散列表是实现字典操作的一种有效数据结构，尽管最坏情况下散列表查找一个元素的时间与链表查找的时间相同，达到了O(n)，然而在实际应用中，散列查找的性能是极好的，在一些合理假设下查找一个元素的平均时间是O(1)
- 当实际存储的关键字数目比全部的可能关键字总数要小时，采用散列表就称为直接数组寻址的一种有效替代，因为散列表使用一个长度与实际存储的关键字数目成比例的数组来存储

### 11.1 直接寻址表

- 当关键字的全域U比较小时，直接寻址是一种简单有效的技术，为表示动态集合，可用一个数组或称为直接寻址表，其中每个位置或称为槽对应全域中的一个关键字，该槽内指针指向集合中对应关键字的值，若集合中没有该关键字则该值为空
- 对于某些应用，直接寻址表本身就可以存放动态集合中的元素，并不需要把每个元素的关键字及其卫星数据都放在直接寻址表外部的一个对象中，再由表中某个槽的指针指向该对象，而是直接把该对象存放在表的槽中从而节省了指针的空间，此时使用对象中的一些关键字表明对象为空。通常不必存储关键字，因为通过下标就可以得到对应关键字
- 缺点：若全域U够大，则在一台标准的计算机可用内存容量中，要存储大小为|U|的一张表不太实际，且实际存储的关键字集合相对于全域来说可能很小，使得分配给直接寻址表的大部分空间都会被浪费

### 11.2 散列表

- 当存储在字典汇总的关键字集合K比所有可能的关键字的全域U要小许多时，散列表需要的存储空间要比直接寻址少的多。存储需求将降至O(k)，且查找一个元素的平均情况需要O(1)
- 利用散列函数h通过关键字k计算出槽的位置，元素存放在槽h(k)中。即散列函数将全域U映射到散列表的槽位上
- 当两个关键字映射到同一个槽中时称为冲突。理想的方法是避免所有冲突，但想要完全避免是不可能的，所以可以通过精心设计散列函数来尽量减少冲突的次数，另一方面仍需要有解决冲突的方法。
- 拉链法将散列到同一槽中的所有元素都放在一个链表中，槽中存储指向链表的表头的指针，若不存在该链表则为null。其插入操作最坏为O(1)，查找操作最坏为O(n)，若散列表中的链表是双链表则知道删除结点删除操作为O(1)，否则需要查找前驱结点和查找渐进时间相同
- 散列方法的平均性能依赖于所选取的散列函数h，将所有的关键字集合分布在m个槽位的均匀程度

### 11.3 散列函数

- 一个好的散列函数应近似的满足简单均匀散列假设：每个关键字都可被等可能的散列到m个槽位中的任何一个，并与其他关键字已散列到哪个槽位无关。但一般无法检测该条件是否成立，因为很少能知道关键字散列所满足的概率分布，且关键字可能并不是完全独立
- 实际应用中常常可以根据启发式方法来构造性能较好的散列函数，即根据具体的情况进行构建
- 一种好的散列函数得出的散列值在某种程度上应独立于数据可能存在的任何形式
- 散列函数的某些应用可能会要求比简单均匀散列更强的性质，如近似的关键字拥有截然不同的散列值
- 多数散列函数都假定关键字的全域为自然数集，所有若给出的关键字不是自然数，则需要找到一种方法将其转换为自然数

#### 11.3.1 除法散列法

